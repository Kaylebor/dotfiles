;; -*- lexical-binding: t; -*-

;; Automatic tree-sitter mode management
(use-package treesit-auto
  :ensure t
  :custom
  (treesit-auto-install 'prompt)  ; Prompt before installing missing grammars
  :config
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))

;; Helper functions for grammar management
(defun treesit-delete-grammar (lang)
  "Delete grammar for LANG (symbol, e.g., 'python)."
  (interactive
   (list (intern (completing-read "Grammar to delete: "
                                  (mapcar #'treesit-auto-recipe-lang
                                          treesit-auto-recipe-list)))))
  (let ((grammar-dir (expand-file-name (symbol-name lang)
                                       (expand-file-name "tree-sitter" user-emacs-directory))))
    (when (file-directory-p grammar-dir)
      (delete-directory grammar-dir 'recursive)
      (message "Deleted grammar: %s" lang))))

(defun treesit-delete-all-grammars ()
  "Delete all installed tree-sitter grammars."
  (interactive)
  (when (y-or-n-p "Delete ALL tree-sitter grammars? ")
    (let ((grammar-root (expand-file-name "tree-sitter" user-emacs-directory)))
      (when (file-directory-p grammar-root)
        (delete-directory grammar-root 'recursive)
        (make-directory grammar-root)
        (message "All grammars deleted. Run treesit-auto-install-all to reinstall.")))))

(use-package emacs-lisp-mode
  :ensure nil
  :delight
  :mode ("\\.el\\'" . emacs-lisp-mode))

(use-package sh-mode
  :ensure nil
  :delight
  :mode ("\\.fish\\(rc\\)?\\'" . sh-mode))

(use-package sql-mode
  :ensure nil
  :delight
  :mode ("\\.sql\\'" . sql-mode)
  :hook (sql-mode . lsp-deferred))

;; PostgreSQL wire protocol library (lambda password support is upstream)
(use-package pg
  :ensure t)

;; PostgreSQL database browser and editor
(use-package pgmacs
  :ensure (:host github :repo "emarsden/pgmacs")
  :defer t)

;; PostgreSQL execution mode with auth-source integration
(use-package pgx-mode
  :ensure (:host github 
                 :repo "Kaylebor/pgx-mode"
                 :files ("*.el"))  ; Include all .el files
  :after (sql pg)  ; Let elpaca handle dependencies from Package-Requires
  :hook (sql-mode . pgx-mode)
  :config
  ;; Enable pgmacs display if available
  (when (and (featurep 'pgmacs) (featurep 'pgx-mode-pgmacs))
    (pgx-enable-pgmacs-display))
  ;; Load device-specific PostgreSQL connections
  (let ((sql-config-file "~/.config/emacs/sql-connections.el"))
    (when (file-exists-p sql-config-file)
      (load sql-config-file))))

;; Configure sqls LSP for completions (localhost only)
;; Note: sqls reads connections from .sqls/config.json in project root

(use-package dbml-mode
  :ensure t
  :delight
  :mode ("\\.dbml\\'" . dbml-mode))


(use-package javascript-ts-mode
  :ensure nil
  :delight
  :mode (("\\.jsx\\'" . js-jsx-mode)))  ; jsx still needs explicit mode

(use-package json-mode
  :ensure t
  :delight
  :mode (("\\.jsonc\\'" . jsonc-mode)))  ; JSON with comments

(use-package elixir-ts-mode
  :ensure nil
  :delight
  :mode ("\\.\\(ex\\|exs\\|eex\\|leex\\|heex\\)\\'" . elixir-ts-mode))

;; Zig programming language
(use-package zig-mode
  :ensure t
  :delight
  :mode ("\\.\\(zig\\|zon\\)\\'" . zig-mode)
  :custom
  (zig-format-on-save nil))     ; Disable built-in formatter (apheleia handles it)

(use-package gdscript-mode :ensure (:host github :repo "godotengine/emacs-gdscript-mode") :delight :mode ("\\.gd\\'" . gdscript-ts-mode))

;; Linting - using built-in Flymake (enhanced via ELPA)
(use-package flymake
  :ensure t
  :bind ("C-c ! n" . flymake-goto-next-error)
  :bind ("C-c ! p" . flymake-goto-prev-error)
  :bind ("C-c ! l" . flymake-show-buffer-diagnostics))

;; Collection of checkers for non-LSP modes
(use-package flymake-collection
  :ensure t
  :hook (after-init . flymake-collection-hook-setup))

;; Automatic code formatting on save
(use-package apheleia :ensure t
  :config
  ;; Hide from modeline by setting lighter to empty
  (setq apheleia-mode-lighter "")
  ;; Enable globally - formats on save without interrupting
  (apheleia-global-mode +1)
  ;; Ensure formatters use mise-managed tools
  ;; Apheleia will automatically find these in PATH via mise
  ;; No additional configuration needed for standard formatters:
  ;; - prettier (JS/TS/HTML/CSS/JSON/YAML)
  ;; - black/ruff (Python)
  ;; - gofmt/goimports (Go)
  ;; - mix format (Elixir)
  ;; - rubocop/standardrb (Ruby)
  ;; - rustfmt (Rust)
  ;; - shfmt (Shell)
  )

;; Force-update jsonrpc for eglot
(use-package jsonrpc :ensure t)

(defun user-eglot-framework-aware-contact (mise-contact &optional _interactive project)
  "Return 'rass angular' if in Angular project, else MISE-CONTACT."
  (let* ((root (if project (project-root project)
                 (let ((proj (project-current)))
                   (and proj (project-root proj)))))
         (root (or root default-directory))
         (is-angular (and root (file-exists-p (expand-file-name "angular.json" root)))))
    (if is-angular '("rass" "angular") mise-contact)))

(use-package eglot :ensure t
  :delight
  :defer t
  :config
  ;; Cleanup existing entries for modes we're about to wrap
  (setq eglot-server-programs
        (cl-loop for entry in eglot-server-programs
                 unless (let ((modes (car entry)))
                          (and (listp modes)
                               (cl-some (lambda (m) 
                                          (memq (if (listp m) (car m) m) 
                                                '(js-mode js-ts-mode html-mode html-ts-mode css-mode css-ts-mode json-mode json-ts-mode)))
                                        modes)))
                 collect entry))
  (add-to-list 'eglot-server-programs
               '(((js-mode :language-id "javascript")
                  (js-ts-mode :language-id "javascript")
                  (tsx-ts-mode :language-id "typescriptreact")
                  (typescript-ts-mode :language-id "typescript")
                  (typescript-mode :language-id "typescript"))
                 . (lambda (i p) (user-eglot-framework-aware-contact '("typescript-language-server" "--stdio") i p))))
  (add-to-list 'eglot-server-programs
               '((html-mode html-ts-mode mhtml-mode mhtml-ts-mode)
                 . (lambda (i p) (user-eglot-framework-aware-contact '("vscode-html-language-server" "--stdio") i p))))
  (add-to-list 'eglot-server-programs
               '((css-mode css-ts-mode scss-mode scss-ts-mode)
                 . (lambda (i p) (user-eglot-framework-aware-contact '("vscode-css-language-server" "--stdio") i p))))
  (add-to-list 'eglot-server-programs
               '((json-mode json-ts-mode jsonc-mode)
                 . (lambda (i p) (user-eglot-framework-aware-contact '("vscode-json-language-server" "--stdio") i p))))
  :hook ((ruby-mode
          ruby-ts-mode
          html-mode
          html-ts-mode
          mhtml-mode
          mhtml-ts-mode
          javascript-mode
          js-mode
          js-ts-mode
          js-jsx-mode
          js-json-mode
          typescript-ts-mode
          tsx-ts-mode
          go-ts-mode
          lua-mode
          lua-ts-mode
          elixir-ts-mode
          gdscript-ts-mode
          rust-ts-mode
          css-mode
          css-ts-mode
          scss-mode
          json-mode
          jsonc-mode
           json-ts-mode) . eglot-ensure)

  ;; Enable LSP semantic highlighting (context-aware highlighting)
  ;; Provides semantic understanding: types, scopes, declarations, etc.
  ;; Works alongside tree-sitter for enhanced accuracy
  (eglot-managed-mode . eglot-semantic-tokens-mode)
  
  ;; Enable inlay hints (parameter names and types shown inline)
  ;; Example: function foo(param1, param2) shows parameter names inline
  (eglot-managed-mode . eglot-inlay-hints-mode))

;; Use Stylua for Lua formatting if available (managed by mise)
(with-eval-after-load 'apheleia
  (add-to-list 'apheleia-mode-alist '(lua-ts-mode . stylua)))

;; Corfu for in-buffer completion (works great with LSP)
(use-package corfu :ensure t
  :custom
  (corfu-cycle t)                    ;; Enable cycling for `corfu-next/previous'
  (corfu-auto t)                     ;; Enable auto completion
  (corfu-auto-delay 0.3)             ;; Delay before auto completion
  (corfu-auto-prefix 2)              ;; Minimum prefix length for auto completion
  (corfu-separator ?\s)              ;; Orderless field separator
  (corfu-quit-at-boundary 'separator) ;; Quit at completion boundary
  (corfu-quit-no-match 'separator)   ;; Quit when no match with separator
  (corfu-preview-current 'insert)    ;; Preview current candidate on insert
  (corfu-preselect 'prompt)          ;; Preselect the prompt
  (corfu-on-exact-match nil)         ;; Don't auto-select exact matches
  (corfu-scroll-margin 5)            ;; Use scroll margin
  :init
  (global-corfu-mode)
  
  ;; Enable Corfu in minibuffer for eval-expression etc.
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      (setq-local corfu-auto nil)  ; Disable auto completion
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer))

;; Add extensions
(use-package corfu-popupinfo :ensure nil
  :after corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :custom
  (corfu-popupinfo-delay '(0.5 . 0.1))   ; Quick popup after selection
  (corfu-popupinfo-hide nil)             ; Don't hide automatically
  (corfu-popupinfo-max-height 20)        ; Maximum height for docs
  (corfu-popupinfo-max-width 80)         ; Maximum width for docs
  :config
  (corfu-popupinfo-mode)
  ;; Use M-d to manually toggle documentation during completion
  (define-key corfu-map (kbd "M-d") #'corfu-popupinfo-toggle)
  ;; M-n/M-p to scroll the documentation
  (define-key corfu-map (kbd "M-n") #'corfu-popupinfo-scroll-up)
  (define-key corfu-map (kbd "M-p") #'corfu-popupinfo-scroll-down))

;; Corfu terminal support - only needed for Emacs < 31
(use-package corfu-terminal :ensure t
  :if (and (not (display-graphic-p))
           (< emacs-major-version 31))
  :config
  (corfu-terminal-mode +1))

;; Icons in completion
(use-package kind-icon :ensure t
  :after corfu
  :custom
  (kind-icon-default-face 'corfu-default) ; Use corfu face as background
  (kind-icon-use-icons t)
  (kind-icon-blend-background t)
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

;; Cape completion extensions
(use-package cape :ensure t
  :init
  ;; Add to the global default value of `completion-at-point-functions' which is
  ;; used by `completion-at-point'.  The order of the functions matters, the
  ;; first function returning a result wins.  Note that the list of buffer-local
  ;; completion functions takes precedence over the global list.
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  ;; cape-keyword for programming modes
  (add-hook 'prog-mode-hook
            (lambda ()
              (add-to-list 'completion-at-point-functions #'cape-keyword t))))

(use-package dape :ensure t
  :defer t
  :custom
  (dape-breakpoint-global-mode +1)
  (dape-buffer-window-arrangement 'right)
  (dape-cwd-function (lambda () (let ((p (project-current))) (if p (project-root p) default-directory))))
  :config
  (add-hook 'dape-start-hook (lambda () (save-some-buffers t t))))

;; Load chezmoi template support (composite grammars for .tmpl files)
(load-file (expand-file-name "chezmoi-templates.el" user-emacs-directory))
