#!/usr/bin/env uv run python
"""
Homebrew package installer for Chezmoi with proper packages.yml integration.
"""

import argparse
import os
import subprocess
import sys
import yaml
from pathlib import Path
from math import inf
from typing import List, Dict, Any, Optional


class HomebrewPackageInstaller:
    def __init__(self):
        self.chezmoi_source_dir = Path(os.environ.get("CHEZMOI_SOURCE_DIR", os.getcwd()))
        self.packages_file = self.chezmoi_source_dir / ".chezmoidata" / "packages.yml"
    
    def _get_brew_prefix(self) -> Optional[Path]:
        """Get Homebrew prefix."""
        try:
            result = subprocess.run(["brew", "--prefix"], capture_output=True, text=True, check=True)
            return Path(result.stdout.strip())
        except subprocess.CalledProcessError:
            return None
    
    def _is_alternative_homebrew(self) -> bool:
        """Check if this is an alternative Homebrew installation."""
        brew_prefix = self._get_brew_prefix()
        if not brew_prefix:
            return False
        return str(brew_prefix).startswith(str(Path.home()))
    
    def _load_packages_config(self) -> Dict[str, Any]:
        """Load packages configuration from packages.yml."""
        if not self.packages_file.exists():
            print(f"Warning: Packages file not found: {self.packages_file}")
            return {}
        
        try:
            with open(self.packages_file, 'r') as f:
                return yaml.safe_load(f) or {}
        except Exception as e:
            print(f"Error loading packages config: {e}")
            return {}
    
    def _get_package_config(self, package_name: str) -> Optional[Dict[str, Any]]:
        """Get configuration for a specific package from packages.yml."""
        config = self._load_packages_config()
        packages = config.get('packages', {})
        darwin_brews = packages.get('darwin', {}).get('brews', [])
        
        for pkg in darwin_brews:
            if isinstance(pkg, dict) and pkg.get('name') == package_name:
                return pkg
            elif isinstance(pkg, str) and pkg == package_name:
                return {'name': pkg}
        
        return None

    def _get_install_order(self, package_name: str) -> float:
        """Return the install order for a package, lower runs earlier.

        Looks for 'install_order' at the top level of the package config,
        otherwise falls back to alternative_only.install_order.
        Returns +inf when unspecified to push to the end, preserving
        input order among equals.
        """
        pkg_cfg = self._get_package_config(package_name)
        if not pkg_cfg:
            return inf
        value = pkg_cfg.get('install_order')
        if isinstance(value, int):
            return float(value)
        alt = pkg_cfg.get('alternative_only')
        if isinstance(alt, dict):
            alt_value = alt.get('install_order')
            if isinstance(alt_value, int):
                return float(alt_value)
        return inf
    
    def force_reinstall_packages(self, packages: List[str]) -> bool:
        """Force reinstall packages with proper configuration from packages.yml."""
        if not self._is_alternative_homebrew():
            print("Not an alternative Homebrew installation, using simple reinstall...")
            return self._simple_reinstall_packages(packages)
        
        print("Alternative Homebrew installation detected, using complex installation logic...")
        
        # Validate package names
        valid_packages = []
        for pkg in packages:
            pkg = pkg.strip()
            if not pkg:
                continue
            if not all(c.isalnum() or c in '@+-_' for c in pkg):
                print(f"Warning: Invalid package name '{pkg}', skipping")
                continue
            valid_packages.append(pkg)
        
        if not valid_packages:
            print("No valid packages to install")
            return False
        
        # Sort by install_order (data-first ordering); stable by original index
        indexed = list(enumerate(valid_packages))
        indexed.sort(key=lambda t: (self._get_install_order(t[1]), t[0]))
        sorted_packages = [p for _, p in indexed]

        # Uninstall packages first
        print("Uninstalling packages for clean reinstall...")
        for pkg in sorted_packages:
            try:
                result = subprocess.run(["brew", "list", "--formula"], capture_output=True, text=True)
                if result.returncode == 0 and pkg in result.stdout.splitlines():
                    print(f"Uninstalling {pkg} for clean reinstall...")
                    subprocess.run(["brew", "uninstall", "--ignore-dependencies", pkg], 
                                 check=True)
            except subprocess.CalledProcessError as e:
                print(f"Warning: Failed to uninstall {pkg}: {e}")
        
        # Install packages with proper configuration from packages.yml
        print("Installing packages with configuration from packages.yml...")
        for pkg in sorted_packages:
            pkg_config = self._get_package_config(pkg)
            if pkg_config:
                if not self._install_package_with_config(pkg, pkg_config):
                    print(f"Warning: Failed to install package {pkg}")
            else:
                if not self._install_package(pkg):
                    print(f"Warning: Failed to install package {pkg}")
        
        return True
    
    def _simple_reinstall_packages(self, packages: List[str]) -> bool:
        """Simple reinstall for standard Homebrew installations."""
        for pkg in packages:
            pkg = pkg.strip()
            if not pkg:
                continue
            
            try:
                result = subprocess.run(["brew", "list", "--formula"], capture_output=True, text=True)
                if result.returncode == 0 and pkg in result.stdout.splitlines():
                    print(f"Uninstalling {pkg} for clean reinstall...")
                    subprocess.run(["brew", "uninstall", "--ignore-dependencies", pkg], check=True)
                
                print(f"Installing {pkg}...")
                subprocess.run(["brew", "install", pkg], check=True)
            except subprocess.CalledProcessError as e:
                print(f"Error with {pkg}: {e}")
                return False
        
        return True
    
    def _install_package(self, package: str) -> bool:
        """Install a single package with basic configuration."""
        try:
            print(f"Installing {package}")
            
            # Prepare environment for installation
            env = os.environ.copy()
            
            # Special handling for Fortran-dependent packages
            if package in ["lapack", "openblas", "octave"]:
                brew_prefix = self._get_brew_prefix()
                if brew_prefix:
                    gfortran_path = brew_prefix / "bin" / "gfortran"
                    if gfortran_path.exists():
                        env.update({
                            "FC": str(gfortran_path),
                            "F77": str(gfortran_path),
                            "F90": str(gfortran_path)
                        })
                        print(f"Installing {package} with Fortran compiler configuration...")
            
            # Install the package
            result = subprocess.run(["brew", "install", package], 
                                  env=env, capture_output=True, text=True)
            
            if result.returncode == 0:
                # Special post-installation handling
                if package == "gcc":
                    self._setup_gcc_symlinks()
                return True
            else:
                print(f"Error installing {package}: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"Error installing {package}: {e}")
            return False
    
    def _install_package_with_config(self, package: str, config: Dict[str, Any]) -> bool:
        """Install a single package with configuration from packages.yml."""
        try:
            print(f"Installing {package} with configuration...")
            
            # Prepare environment for installation
            env = os.environ.copy()
            
            # Handle environment variables
            if 'env' in config:
                env.update(config['env'])
                print(f"Applied environment variables: {config['env']}")
            
            # Handle alternative-only environment variables for alternative Homebrew
            if self._is_alternative_homebrew() and 'alternative_only' in config:
                alt_config = config['alternative_only']
                if 'env' in alt_config:
                    env.update(alt_config['env'])
                    print(f"Applied alternative environment variables: {alt_config['env']}")
            
            # Special handling for Fortran-dependent packages
            if package in ["lapack", "openblas", "octave"]:
                brew_prefix = self._get_brew_prefix()
                if brew_prefix:
                    gfortran_path = brew_prefix / "bin" / "gfortran"
                    if gfortran_path.exists():
                        env.update({
                            "FC": str(gfortran_path),
                            "F77": str(gfortran_path),
                            "F90": str(gfortran_path)
                        })
                        print(f"Installing {package} with Fortran compiler configuration...")
            
            # Build brew install command with arguments
            cmd = ["brew", "install"]
            
            # Add package name
            cmd.append(package)
            
            # Add arguments
            if 'args' in config:
                for arg in config['args']:
                    cmd.extend([f"--{arg}"])
                print(f"Added arguments: {config['args']}")
            
            # Add alternative-only arguments for alternative Homebrew
            if self._is_alternative_homebrew() and 'alternative_only' in config:
                alt_config = config['alternative_only']
                if 'args' in alt_config:
                    for arg in alt_config['args']:
                        cmd.extend([f"--{arg}"])
                    print(f"Added alternative arguments: {alt_config['args']}")
            
            # Install the package
            result = subprocess.run(cmd, env=env, capture_output=True, text=True)
            
            if result.returncode == 0:
                # Special post-installation handling
                if package == "gcc":
                    self._setup_gcc_symlinks()
                return True
            else:
                print(f"Error installing {package}: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"Error installing {package}: {e}")
            return False
    
    def _setup_gcc_symlinks(self):
        """Setup GCC symlinks for alternative Homebrew installations."""
        try:
            brew_prefix = self._get_brew_prefix()
            if not brew_prefix:
                return
            
            bin_dir = brew_prefix / "bin"
            if not bin_dir.exists():
                return
            
            # Find all gcc versions
            gcc_versions = []
            for item in bin_dir.iterdir():
                if item.name.startswith("gcc-") and item.is_file():
                    version = item.name[4:]  # Remove "gcc-" prefix
                    if version.replace(".", "").isdigit():  # Basic version validation
                        gcc_versions.append(version)
            
            if not gcc_versions:
                print("No GCC versions found for symlink setup")
                return
            
            latest_version = max(gcc_versions)
            print(f"Setting up gcc/gfortran symlinks for version {latest_version}...")
            
            # Create symlinks for gcc tools
            tools = ["gcc", "g++", "gfortran"]
            for tool in tools:
                versioned_tool = f"{tool}-{latest_version}"
                versioned_path = bin_dir / versioned_tool
                symlink_path = bin_dir / tool
                
                if versioned_path.exists():
                    # Check if symlink already points to the correct target
                    if symlink_path.exists():
                        if symlink_path.is_symlink():
                            try:
                                current_target = symlink_path.readlink()
                                if current_target.name == versioned_tool:
                                    print(f"Symlink already correct: {symlink_path} -> {versioned_tool}")
                                    continue
                            except Exception:
                                pass
                        # Remove existing file/symlink
                        symlink_path.unlink()
                    
                    # Create new symlink
                    symlink_path.symlink_to(versioned_tool)
                    print(f"Created symlink: {symlink_path} -> {versioned_tool}")
            
            # Set Fortran compiler environment variables (only for this process)
            gfortran_path = bin_dir / "gfortran"
            if gfortran_path.exists():
                # Only update if not already set
                if not os.environ.get("FC"):
                    os.environ["FC"] = str(gfortran_path)
                if not os.environ.get("F77"):
                    os.environ["F77"] = str(gfortran_path)
                if not os.environ.get("F90"):
                    os.environ["F90"] = str(gfortran_path)
                
        except Exception as e:
            print(f"Warning: Failed to setup GCC symlinks: {e}")


def main():
    parser = argparse.ArgumentParser(
        description="Homebrew package installer for Chezmoi"
    )
    parser.add_argument(
        "command",
        choices=["force-reinstall"],
        help="Command to execute"
    )
    parser.add_argument(
        "packages",
        nargs="+",
        help="Packages to install"
    )
    
    args = parser.parse_args()
    
    installer = HomebrewPackageInstaller()
    
    if args.command == "force-reinstall":
        success = installer.force_reinstall_packages(args.packages)
        sys.exit(0 if success else 1)
    else:
        print(f"Unknown command: {args.command}")
        sys.exit(1)


if __name__ == "__main__":
    main()
