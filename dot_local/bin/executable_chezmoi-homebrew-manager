#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#   "pyyaml",
#   "networkx",
# ]
# ///
"""
Comprehensive Homebrew manager for Chezmoi with full macOS installation logic.
Handles all complex Homebrew operations extracted from the bash template.
"""

import argparse
import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from homebrew_manager import PackagesHelper, RebuildService


class HomebrewManager:
    def __init__(self, packages_file: Optional[Path] = None, *, dry_run: bool = False):
        self.chezmoi_source_dir = Path(os.environ.get("CHEZMOI_SOURCE_DIR", os.getcwd()))
        self.packages_file = packages_file or (self.chezmoi_source_dir / ".chezmoidata" / "packages.yml")
        self.config: Dict[str, Any] = {}
        self._formulae_cache: Optional[Dict[str, Any]] = None
        self._packages_helper: Optional[PackagesHelper] = None
        self._rebuild_service: Optional[RebuildService] = None
        self.dry_run = dry_run
    
    def _setup_environment(self) -> None:
        """Set up Homebrew environment based on configuration."""
        if not self.config:
            return
            
        # Update source directory from config if provided
        if "chezmoi_source_dir" in self.config:
            self.chezmoi_source_dir = Path(self.config["chezmoi_source_dir"])
            if not self.packages_file.parent.name == ".chezmoidata":
                self.packages_file = self.chezmoi_source_dir / ".chezmoidata" / "packages.yml"
        # Reset helpers that depend on configuration
        self._packages_helper = None
        self._rebuild_service = None
    
    def load_runtime_config(self, config_json: str) -> None:
        """Load runtime configuration from JSON string."""
        try:
            self.config = json.loads(config_json)
            self._setup_environment()
        except json.JSONDecodeError as e:
            print(f"Error parsing runtime config JSON: {e}")
            sys.exit(1)
    
    def _get_brew_prefix(self) -> Optional[Path]:
        """Get Homebrew prefix."""
        try:
            result = subprocess.run(["brew", "--prefix"], capture_output=True, text=True, check=True)
            return Path(result.stdout.strip())
        except subprocess.CalledProcessError:
            return None
    
    def _is_alternative_homebrew(self) -> bool:
        """Check if this is an alternative Homebrew installation."""
        return self.config.get("homebrew_type") == "alternative"
    
    def _get_running_services(self) -> Dict[str, str]:
        """Get currently running brew services and their status."""
        try:
            result = subprocess.run(["brew", "services", "list"], 
                                  capture_output=True, text=True, check=True)
            
            services = {}
            for line in result.stdout.strip().split('\n')[1:]:  # Skip header
                if line:
                    parts = line.split()
                    if len(parts) >= 2:
                        service_name = parts[0]
                        status = parts[1]  # 'started', 'stopped', 'error', etc.
                        services[service_name] = status
            
            return services
            
        except subprocess.CalledProcessError as e:
            print(f"Warning: Could not get brew services list: {e}")
            return {}
    
    def _stop_service(self, service_name: str) -> bool:
        """Stop a brew service."""
        try:
            print(f"  Stopping service: {service_name}")
            subprocess.run(["brew", "services", "stop", service_name], 
                         check=True, capture_output=True)
            return True
        except subprocess.CalledProcessError:
            return False
    
    def _start_service(self, service_name: str) -> bool:
        """Start a brew service."""
        try:
            print(f"  Starting service: {service_name}")
            subprocess.run(["brew", "services", "start", service_name], 
                         check=True, capture_output=True)
            return True
        except subprocess.CalledProcessError as e:
            print(f"  Warning: Failed to start service {service_name}: {e}")
            return False
    
    def _restart_service(self, service_name: str) -> bool:
        """Restart a brew service."""
        try:
            print(f"  Restarting service: {service_name}")
            subprocess.run(["brew", "services", "restart", service_name], 
                         check=True, capture_output=True)
            return True
        except subprocess.CalledProcessError as e:
            print(f"  Warning: Failed to restart service {service_name}: {e}")
            return False
    
    def _get_all_formulae_info(self, force_refresh: bool = False) -> Dict[str, Any]:
        """Get cached formulae info, fetching if needed."""
        if self._formulae_cache is None or force_refresh:
            try:
                result = subprocess.run(["brew", "info", "--json=v2", "--installed"], 
                                      capture_output=True, text=True, check=True)
                data = json.loads(result.stdout)
                
                # Create a dictionary keyed by formula name for quick lookup
                self._formulae_cache = {}
                for formula in data['formulae']:
                    name = formula['name']
                    self._formulae_cache[name] = formula
                    # Also store by full name if different
                    if formula.get('full_name') and formula['full_name'] != name:
                        self._formulae_cache[formula['full_name']] = formula
                        
            except (subprocess.CalledProcessError, json.JSONDecodeError) as e:
                print(f"Error fetching formulae info: {e}")
                self._formulae_cache = {}
                
        return self._formulae_cache

    def _get_packages_helper(self) -> PackagesHelper:
        if self._packages_helper is None:
            self._packages_helper = PackagesHelper.load(
                self.packages_file,
                is_alternative=self._is_alternative_homebrew(),
            )
        return self._packages_helper

    def _get_rebuild_service(self) -> RebuildService:
        if self._rebuild_service is None:
            self._rebuild_service = RebuildService(
                get_formulae_info=self._get_all_formulae_info,
                packages_helper=self._get_packages_helper(),
                stop_service=self._stop_service,
                start_service=self._start_service,
                install_package=lambda pkg_config, reinstall=True: self.install_individual_package(
                    pkg_config, reinstall=reinstall
                ),
                dry_run=self.dry_run,
                is_alternative=self._is_alternative_homebrew,
            )
        return self._rebuild_service

    def install_homebrew(self) -> bool:
        """Install Homebrew if not present."""
        if self.config.get("has_brew"):
            return True
        
        print("Installing Homebrew...")
        
        if self._is_alternative_homebrew():
            # Alternative installation
            homebrew_path = self.config.get("homebrew_path", "homebrew")
            tarball_url = self.config.get("homebrew_tarball_url")
            
            if not tarball_url:
                print("Error: Missing homebrew_tarball_url in config")
                return False
            
            print(f"Installing Homebrew to {homebrew_path} for MDM compatibility...")
            
            home_dir = Path.home()
            homebrew_dir = home_dir / homebrew_path
            
            try:
                homebrew_dir.mkdir(parents=True, exist_ok=True)
                
                # Download and extract
                cmd = f'curl -L {tarball_url} | tar xz --strip-components 1 -C "{homebrew_dir}"'
                subprocess.run(cmd, shell=True, check=True)
                
                # Set up environment
                brew_env_cmd = f"{homebrew_dir}/bin/brew shellenv"
                result = subprocess.run(brew_env_cmd, shell=True, capture_output=True, text=True, check=True)
                
                # Apply environment to current process
                for line in result.stdout.strip().split('\n'):
                    if line.startswith('export '):
                        key_value = line[7:]  # Remove 'export '
                        if '=' in key_value:
                            key, value = key_value.split('=', 1)
                            value = value.strip('"\'')
                            os.environ[key] = value
                
                # Update and fix permissions
                subprocess.run(["brew", "update", "--force", "--quiet"], check=True)
                
                brew_bin = self.config.get("brew_bin")
                if brew_bin:
                    zsh_dir = Path(subprocess.run([brew_bin, "--prefix"], capture_output=True, text=True, check=True).stdout.strip()) / "share" / "zsh"
                    if zsh_dir.exists():
                        subprocess.run(["chmod", "-R", "go-w", str(zsh_dir)], check=False)
                
                return True
                
            except subprocess.CalledProcessError as e:
                print(f"Error installing alternative Homebrew: {e}")
                return False
        else:
            # Standard installation
            install_url = self.config.get("homebrew_install_url", "https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh")
            
            try:
                cmd = f'/bin/bash -c "$(curl -fsSL {install_url})"'
                subprocess.run(cmd, shell=True, check=True)
                return True
            except subprocess.CalledProcessError as e:
                print(f"Error installing standard Homebrew: {e}")
                return False
    
    def verify_formula_patches(self) -> bool:
        """Verify formula patches before applying."""
        if not self._is_alternative_homebrew():
            return True
        
        formula_patches = self._get_packages_helper().formula_patches
        
        if not formula_patches:
            return True
        
        print("Verifying formula patches for alternative Homebrew...")
        
        for formula, patch_config in formula_patches.items():
            # Skip if package is already installed
            result = subprocess.run(["brew", "list", formula], capture_output=True)
            if result.returncode == 0:
                continue
            
            # If no expected_hash is set and there is no corresponding patch file, skip hash verification
            expected_hash = (patch_config or {}).get("expected_hash")
            patch_file_path = self.chezmoi_source_dir / "scripts" / "patches" / f"{formula}.patch"
            if not expected_hash and not patch_file_path.exists():
                print(f"Skipping hash check for {formula} (no expected_hash and no patch file)")
                continue

            print(f"Verifying {formula} formula hash...")
            
            # Get formula path
            try:
                repo_result = subprocess.run(["brew", "--repository", "homebrew/core"], 
                                           capture_output=True, text=True, check=True)
                repo_path = Path(repo_result.stdout.strip())
                formula_path = repo_path / "Formula" / formula[0] / f"{formula}.rb"
                
                if not formula_path.exists():
                    print(f"⚠️  Formula not found: {formula_path}")
                    continue
                
                # Calculate actual hash
                result = subprocess.run(["shasum", "-a", "256", str(formula_path)], 
                                      capture_output=True, text=True, check=True)
                actual_hash = result.stdout.split()[0]
                
                if actual_hash != expected_hash:
                    print(f"❌ Hash mismatch for {formula}!")
                    print(f"   Expected: {expected_hash}")
                    print(f"   Actual:   {actual_hash}")
                    print(f"   Description: {patch_config.get('description', 'No description')}")
                    
                    issue_url = patch_config.get("issue_url")
                    if issue_url:
                        print(f"   Related issue: {issue_url}")
                    
                    print("   The formula may have been updated upstream.")
                    print("   Please update the patch and expected hash.")
                    return False
                else:
                    print(f"✅ {formula} formula hash verified")
                    print(f"   Patch: {patch_config.get('description', 'No description')}")
                    
            except subprocess.CalledProcessError as e:
                print(f"Error verifying formula {formula}: {e}")
                return False
        
        return True
    
    def install_taps(self) -> bool:
        """Install Homebrew taps."""
        taps = self._get_packages_helper().taps
        
        if not taps:
            return True
        
        print("Installing Homebrew taps...")
        for tap in taps:
            try:
                print(f"Tapping {tap}...")
                subprocess.run(["brew", "tap", tap], check=True)
            except subprocess.CalledProcessError as e:
                print(f"Error tapping {tap}: {e}")
                return False
        
        return True
    
    def classify_packages(self) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]], List[str]]:
        """Classify packages for installation strategy."""
        helper = self._get_packages_helper()
        brews = helper.brews
        casks = helper.casks
        
        # Classify brews
        individual_brews = []  # Packages needing individual installation (with env vars)
        bundle_brews = []      # Packages for brew bundle
        
        for pkg in brews:
            if isinstance(pkg, str):
                bundle_brews.append({"name": pkg, "type": "string"})
            elif isinstance(pkg, dict):
                # Check if package needs individual installation
                has_env = "env" in pkg
                has_alt_env = (self._is_alternative_homebrew() and 
                              "alternative_only" in pkg and 
                              "env" in pkg["alternative_only"])
                
                if has_env or has_alt_env:
                    individual_brews.append(pkg)
                else:
                    bundle_brews.append(pkg)
        
        # Process casks with skip conditions
        processed_casks = []
        for cask in casks:
            if isinstance(cask, str):
                processed_casks.append(cask)
            elif isinstance(cask, dict):
                # Handle skip_if_installed logic
                skip_paths = cask.get("skip_if_installed", [])
                if skip_paths:
                    should_skip = False
                    
                    if isinstance(skip_paths, list):
                        for path in skip_paths:
                            expanded_path = Path(path).expanduser()
                            if expanded_path.exists():
                                should_skip = True
                                break
                    else:
                        expanded_path = Path(skip_paths).expanduser()
                        if expanded_path.exists():
                            should_skip = True
                    
                    if not should_skip:
                        processed_casks.append(cask["name"])
                else:
                    processed_casks.append(cask["name"])
        
        return individual_brews, bundle_brews, processed_casks
    
    def install_individual_packages(self, packages: List[Dict[str, Any]]) -> bool:
        """Install packages that need individual handling (environment variables)."""
        if not packages:
            return True
        
        print("Installing packages with isolated environments...")
        
        for pkg in packages:
            pkg_name = pkg.get("name")
            if not pkg_name:
                continue
            
            print(f"Installing {pkg_name} with isolated environment...")
            
            # Build environment
            env = os.environ.copy()
            
            # Apply base environment variables
            if "env" in pkg:
                env.update(pkg["env"])
                print(f"Applied environment variables: {pkg['env']}")
            
            # Apply alternative-only environment variables
            if (self._is_alternative_homebrew() and 
                "alternative_only" in pkg and 
                "env" in pkg["alternative_only"]):
                env.update(pkg["alternative_only"]["env"])
                print(f"Applied alternative environment variables: {pkg['alternative_only']['env']}")
            
            # Build command
            cmd = ["brew", "install", pkg_name]

            # Add arguments
            if "args" in pkg:
                for arg in pkg["args"]:
                    cmd.append(f"--{arg}")

            # Add alternative-only arguments
            if (self._is_alternative_homebrew() and
                "alternative_only" in pkg and
                "args" in pkg["alternative_only"]):
                for arg in pkg["alternative_only"]["args"]:
                    cmd.append(f"--{arg}")

            try:
                subprocess.run(cmd, env=env, check=True)
                print(f"✅ Successfully installed {pkg_name}")
            except subprocess.CalledProcessError as e:
                print(f"❌ Error installing {pkg_name}: {e}")
                return False
        
        return True
    
    def force_reinstall_packages(self, packages: List[str]) -> bool:
        """Force reinstall packages with proper configuration from packages.yml."""
        if self.dry_run:
            print(f"[dry-run] Would force reinstall packages: {', '.join(packages)}")
        if not packages:
            print("No packages to reinstall")
            return False
        
        # Validate and clean package names
        valid_packages = []
        for pkg in packages:
            pkg = pkg.strip()
            if not pkg:
                continue
            if not all(c.isalnum() or c in '@+-_' for c in pkg):
                print(f"Warning: Invalid package name '{pkg}', skipping")
                continue
            valid_packages.append(pkg)
        
        if not valid_packages:
            print("No valid packages to reinstall")
            return False
        
        print(f"Force reinstalling packages: {', '.join(valid_packages)}")
        
        helper = self._get_packages_helper()
        
        # Sort packages by install order
        sorted_packages = sorted(
            valid_packages,
            key=lambda p: (helper.install_order(p), valid_packages.index(p)),
        )
        
        # Uninstall packages first
        print("Uninstalling packages for clean reinstall...")
        for pkg in sorted_packages:
            try:
                result = subprocess.run(["brew", "list", "--formula"], 
                                      capture_output=True, text=True, check=True)
                if pkg in result.stdout.splitlines():
                    print(f"Uninstalling {pkg}...")
                    subprocess.run(["brew", "uninstall", "--ignore-dependencies", pkg], check=True)
            except subprocess.CalledProcessError as e:
                print(f"Warning: Failed to uninstall {pkg}: {e}")
        
        # Reinstall packages with proper configuration
        print("Reinstalling packages with configuration...")
        for pkg in sorted_packages:
            if not self._install_single_package(pkg):
                print(f"Warning: Failed to reinstall {pkg}")
                return False
        
        return True
    
    def _install_single_package(self, package_name: str) -> bool:
        """Install a single package with its configuration from packages.yml."""
        helper = self._get_packages_helper()
        pkg_config = helper.get_entry(package_name)

        if not pkg_config:
            # Package not in config, install with defaults
            print(f"Installing {package_name} (not in config)")
            try:
                subprocess.run(["brew", "install", package_name], check=True)
                return True
            except subprocess.CalledProcessError as e:
                print(f"Error installing {package_name}: {e}")
                return False

        # Install with configuration
        return self.install_individual_package(pkg_config)

    def detect_outdated_source_builds(self) -> List[Dict[str, Any]]:
        """Wrapper around the rebuild service detection."""
        return self._get_rebuild_service().detect_outdated()

    def rebuild_outdated_packages(self) -> bool:
        """Delegate rebuild execution to the rebuild service."""
        service = self._get_rebuild_service()
        outdated = service.detect_outdated()

        if not outdated:
            print("✅ No source-built packages need rebuilding")
            return True

        print(f"\n⚠️  Found {len(outdated)} source-built packages with outdated dependencies:")
        for pkg in outdated[:10]:
            print(f"  • {pkg['name']} ({pkg['newer_deps_count']}/{pkg['total_deps']} dependencies newer)")
        if len(outdated) > 10:
            print(f"  ... and {len(outdated) - 10} more")

        result = service.rebuild(outdated)

        if result.failed:
            print(f"\n❌ Failed to rebuild {len(result.failed)} packages: {', '.join(result.failed)}")
            print(f"✅ Successfully rebuilt {result.rebuilt} packages")
            return False

        print(f"\n✅ Successfully rebuilt all {result.rebuilt} packages")
        self._formulae_cache = None
        return True
    
    def install_individual_package(self, pkg_config: Dict[str, Any], reinstall: bool = False) -> bool:
        """Install a single package with its configuration."""
        pkg_name = pkg_config.get("name") if isinstance(pkg_config, dict) else pkg_config
        if not pkg_name:
            return False
        
        action = "Reinstalling" if reinstall else "Installing"
        print(f"  {action} {pkg_name}...")
        
        # Build environment
        env = os.environ.copy()
        
        if isinstance(pkg_config, dict):
            # Apply base environment variables
            if "env" in pkg_config:
                env.update(pkg_config["env"])
                print(f"    With env: {pkg_config['env']}")
            
            # Apply alternative-only environment variables
            if (self._is_alternative_homebrew() and 
                "alternative_only" in pkg_config and 
                "env" in pkg_config["alternative_only"]):
                env.update(pkg_config["alternative_only"]["env"])
                print(f"    With alt env: {pkg_config['alternative_only']['env']}")
        
        # Build command
        cmd = ["brew", "reinstall" if reinstall else "install", pkg_name]

        if isinstance(pkg_config, dict):
            # Add arguments
            if "args" in pkg_config:
                for arg in pkg_config["args"]:
                    cmd.append(f"--{arg}")

            # Add alternative-only arguments
            if (self._is_alternative_homebrew() and
                "alternative_only" in pkg_config and
                "args" in pkg_config["alternative_only"]):
                for arg in pkg_config["alternative_only"]["args"]:
                    cmd.append(f"--{arg}")

        try:
            subprocess.run(cmd, env=env, check=True)
            return True
        except subprocess.CalledProcessError as e:
            print(f"    Error: {e}")
            return False
    
    def simple_reinstall_packages(self, packages: List[str]) -> bool:
        """Simple reinstall using brew reinstall (legacy CHEZMOI_REINSTALL_PACKAGES behavior)."""
        if self.dry_run:
            print(f"[dry-run] Would simple reinstall packages: {', '.join(packages)}")
        if not packages:
            print("No packages to reinstall")
            return False
        
        print(f"Simple reinstalling packages: {', '.join(packages)}")
        
        for pkg in packages:
            pkg = pkg.strip()
            if not pkg:
                continue
            
            try:
                # Check if package is installed
                result = subprocess.run(["brew", "list", "--formula"], 
                                      capture_output=True, text=True, check=True)
                if pkg in result.stdout.splitlines():
                    print(f"Reinstalling {pkg}...")
                    subprocess.run(["brew", "reinstall", pkg], check=True)
                else:
                    print(f"Package {pkg} not installed, installing...")
                    subprocess.run(["brew", "install", pkg], check=True)
            except subprocess.CalledProcessError as e:
                print(f"Error with {pkg}: {e}")
                return False
        
        return True

    def generate_brew_bundle(self, brews: List[Dict[str, Any]], casks: List[str]) -> str:
        """Generate brew bundle content."""
        bundle_lines = []
        
        # Add brews
        for brew in brews:
            if brew.get("type") == "string":
                bundle_lines.append(f'brew "{brew["name"]}"')
            else:
                # Map brew package
                line_parts = [f'brew "{brew["name"]}"']
                
                # Add arguments
                if "args" in brew:
                    args_list = [f'"{arg}"' for arg in brew["args"]]
                    line_parts.append(f'args: [{", ".join(args_list)}]')
                
                # Add alternative-only arguments
                if (self._is_alternative_homebrew() and 
                    "alternative_only" in brew and 
                    "args" in brew["alternative_only"]):
                    alt_args = [f'"{arg}"' for arg in brew["alternative_only"]["args"]]
                    line_parts.append(f'args: [{", ".join(alt_args)}]')
                
                bundle_lines.append(", ".join(line_parts))
        
        # Add casks
        for cask in casks:
            bundle_lines.append(f'cask "{cask}"')
        
        return "\n".join(bundle_lines)
    
    def install_with_bundle(self, bundle_content: str) -> bool:
        """Install packages using brew bundle."""
        if not bundle_content.strip():
            return True
        
        print("Installing remaining packages with brew bundle...")
        
        try:
            # Use brew bundle with stdin - show output in real time
            process = subprocess.Popen(
                ["brew", "bundle", "--file=-"],
                stdin=subprocess.PIPE,
                text=True
            )
            
            # Send bundle content and close stdin
            process.communicate(input=bundle_content)
            
            if process.returncode == 0:
                print("✅ Brew bundle installation completed successfully")
                return True
            else:
                print("❌ Brew bundle installation failed")
                return False
                
        except Exception as e:
            print(f"❌ Error running brew bundle: {e}")
            return False
    
    def setup_terminfo(self) -> bool:
        """Set up kitty TERMINFO for Emacs compatibility."""
        # Check if kitty is installed via Homebrew
        try:
            result = subprocess.run(["brew", "list", "--cask"], capture_output=True, text=True, check=True)
            if "kitty" not in result.stdout.splitlines():
                print("Skipping kitty TERMINFO setup (kitty not installed via Homebrew)")
                return True
        except subprocess.CalledProcessError:
            return True
        
        applications_path = self.config.get("applications_path", "/Applications")
        kitty_terminfo_path = Path(applications_path) / "kitty.app" / "Contents" / "Resources" / "kitty" / "terminfo"
        
        if not kitty_terminfo_path.exists():
            print(f"⚠️  Warning: kitty terminfo directory not found: {kitty_terminfo_path}")
            return True
        
        print("Setting up kitty TERMINFO database for Emacs compatibility...")
        
        home_dir = Path.home()
        terminfo_dirs = [home_dir / ".terminfo" / "x", home_dir / ".terminfo" / "78"]
        
        # Create terminfo directories (idempotent)
        for dir_path in terminfo_dirs:
            dir_path.mkdir(parents=True, exist_ok=True)
        
        # Copy kitty terminfo from bundle (always copy to get updates)
        source_file = kitty_terminfo_path / "78" / "xterm-kitty"
        if source_file.exists():
            dest_file = home_dir / ".terminfo" / "x" / "xterm-kitty"
            
            try:
                import shutil
                shutil.copy2(source_file, dest_file)
                print("Updated kitty terminfo at ~/.terminfo/x/xterm-kitty")
                
                # Create/update symlink for hex-based lookup
                symlink_path = home_dir / ".terminfo" / "78" / "xterm-kitty"
                if symlink_path.exists() or symlink_path.is_symlink():
                    symlink_path.unlink()
                
                symlink_path.symlink_to("../x/xterm-kitty")
                print("Updated symlink ~/.terminfo/78/xterm-kitty -> ~/.terminfo/x/xterm-kitty")
                
                print("✅ Kitty TERMINFO setup complete - Emacs should work properly in terminal mode")
                return True
                
            except Exception as e:
                print(f"❌ Error setting up kitty TERMINFO: {e}")
                return False
        else:
            print(f"⚠️  Warning: kitty terminfo file not found at expected location: {source_file}")
            return True
    
    def update_spotlight_index(self) -> bool:
        """Index ~/Applications for Spotlight."""
        if not self._is_alternative_homebrew():
            return True
        
        applications_dir = Path.home() / "Applications"
        if applications_dir.exists():
            print("Indexing ~/Applications for Spotlight...")
            try:
                subprocess.run(["mdimport", str(applications_dir)], check=False)
                return True
            except Exception as e:
                print(f"Warning: Failed to index Applications directory: {e}")
                return True
        
        return True
    
    def install_missing_packages_only(self) -> bool:
        """Install only missing packages (no upgrades)."""
        print("Checking for missing packages...")
        
        # Get currently installed packages
        try:
            result = subprocess.run(["brew", "list", "--formula"], 
                                  capture_output=True, text=True, check=True)
            installed_formulae = set(result.stdout.strip().split('\n'))
            
            result = subprocess.run(["brew", "list", "--cask"], 
                                  capture_output=True, text=True, check=True)
            installed_casks = set(result.stdout.strip().split('\n'))
        except subprocess.CalledProcessError as e:
            print(f"Error getting installed packages: {e}")
            return False
        
        # Classify packages
        individual_brews, bundle_brews, casks = self.classify_packages()
        
        # Filter to only missing packages
        missing_individual = []
        for pkg in individual_brews:
            pkg_name = pkg.get('name') if isinstance(pkg, dict) else pkg
            if pkg_name and pkg_name not in installed_formulae:
                missing_individual.append(pkg)
                print(f"  Missing formula: {pkg_name}")
        
        missing_bundle = []
        for pkg in bundle_brews:
            pkg_name = pkg.get('name') if isinstance(pkg, dict) else pkg
            if pkg_name and pkg_name not in installed_formulae:
                missing_bundle.append(pkg)
                print(f"  Missing formula: {pkg_name}")
        
        missing_casks = []
        for cask in casks:
            cask_name = cask if isinstance(cask, str) else cask.get('name')
            if cask_name and cask_name not in installed_casks:
                missing_casks.append(cask)
                print(f"  Missing cask: {cask_name}")
        
        if not missing_individual and not missing_bundle and not missing_casks:
            print("✅ No missing packages to install")
            return True
        
        # Install missing packages
        print(f"\nInstalling {len(missing_individual) + len(missing_bundle)} missing formulae and {len(missing_casks)} missing casks...")
        
        # Install packages with environment variables first
        if missing_individual and not self.install_individual_packages(missing_individual):
            return False
        
        # Install remaining packages with brew bundle
        if missing_bundle or missing_casks:
            bundle_content = self.generate_brew_bundle(missing_bundle, missing_casks)
            if bundle_content.strip() and not self.install_with_bundle(bundle_content):
                return False
        
        print("✅ Missing packages installed successfully")
        return True
    
    def full_installation(self, first_run: bool = False) -> bool:
        """Perform full Homebrew installation process."""
        if self.dry_run:
            print("[dry-run] Starting full installation workflow")
        if first_run:
            print("Starting initial Homebrew setup...")
        else:
            print("Checking Homebrew packages...")
        
        # Install Homebrew if needed
        if not self.install_homebrew():
            return False
        
        # Set environment variables for alternative Homebrew
        if self._is_alternative_homebrew():
            os.environ["HOMEBREW_NO_INSTALL_FROM_API"] = "1"
            print("Set HOMEBREW_NO_INSTALL_FROM_API=1 to use local formula modifications")
        
        # Verify formula patches
        if not self.verify_formula_patches():
            return False
        
        # Apply formula patches (placeholder - would need template integration)
        # This is where the patch-homebrew-formulas template would be called
        
        # Install taps
        if not self.install_taps():
            return False
        
        if first_run:
            # First run: Install all packages
            print("\nPerforming initial package installation...")
            
            # Classify and install packages
            individual_brews, bundle_brews, casks = self.classify_packages()

            # Sort by install_order (then by original position for stability)
            def _pkg_name(p):
                return p.get("name") if isinstance(p, dict) else p
            individual_brews = sorted(
                list(enumerate(individual_brews)),
                key=lambda t: (self._get_install_order(_pkg_name(t[1])), t[0])
            )
            individual_brews = [p for _, p in individual_brews]

            bundle_brews = sorted(
                list(enumerate(bundle_brews)),
                key=lambda t: (self._get_install_order(_pkg_name(t[1])), t[0])
            )
            bundle_brews = [p for _, p in bundle_brews]
            
            # Install packages with environment variables first
            if not self.install_individual_packages(individual_brews):
                return False
            
            # Install remaining packages with brew bundle
            bundle_content = self.generate_brew_bundle(bundle_brews, casks)
            if not self.install_with_bundle(bundle_content):
                return False
        else:
            # Subsequent runs: Check for outdated packages first, then install missing
            print("\nChecking for package updates...")
            
            # Check for and rebuild outdated source-built packages
            # This is non-critical - don't fail the entire installation if rebuilds fail
            print("\nChecking for outdated source-built packages...")
            try:
                outdated = self.detect_outdated_source_builds()
                if outdated:
                    print(f"Found {len(outdated)} packages that need rebuilding due to dependency updates")
                    if not self.rebuild_outdated_packages():
                        print("⚠️  Some packages failed to rebuild, but installation continues")
                        print("  Run 'brew-check-outdated' manually to retry")
            except Exception as e:
                print(f"⚠️  Warning: Could not check for outdated packages: {e}")
                print("  Run 'brew-check-outdated' manually to check")
            
            # Now install any missing packages
            if not self.install_missing_packages_only():
                return False
        
        # Set up kitty TERMINFO
        if not self.setup_terminfo():
            return False
        
        # Update Spotlight index
        if not self.update_spotlight_index():
            return False
        
        # Update homebrew state file for alternative installations
        if self._is_alternative_homebrew():
            try:
                subprocess.run(["bash", "-c", "update_homebrew_state"], check=False)
                print("Updated homebrew state file")
            except Exception as e:
                print(f"Warning: Failed to update homebrew state: {e}")
        
        # Check for and rebuild outdated source-built packages
        # This is non-critical - don't fail the entire installation if rebuilds fail
        print("\nChecking for outdated source-built packages...")
        try:
            outdated = self.detect_outdated_source_builds()
            if outdated:
                print(f"Found {len(outdated)} packages that need rebuilding due to dependency updates")
                if not self.rebuild_outdated_packages():
                    print("⚠️  Some packages failed to rebuild, but installation continues")
                    print("  Run 'brew-check-outdated' manually to retry")
        except Exception as e:
            print(f"⚠️  Warning: Could not check for outdated packages: {e}")
            print("  Run 'brew-check-outdated' manually to check")
        
        print("✅ Full Homebrew installation completed successfully!")
        return True


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Comprehensive Homebrew manager for Chezmoi"
    )
    parser.add_argument(
        "command",
        choices=[
            "full-install",
            "force-reinstall",
            "simple-reinstall",
            "check-outdated",
            "rebuild-outdated",
        ],
        help="Command to execute",
    )
    parser.add_argument(
        "--config",
        help="Runtime configuration as JSON string",
    )
    parser.add_argument(
        "--packages-file",
        type=Path,
        help="Override path to packages.yml file",
    )
    parser.add_argument(
        "--first-run",
        action="store_true",
        help="Indicate this is the first run (install all packages)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show planned actions without executing them",
    )
    parser.add_argument(
        "packages",
        nargs="*",
        help="Packages for force-reinstall or simple-reinstall commands",
    )
    return parser


def run_full_install(manager: HomebrewManager, args: argparse.Namespace) -> int:
    if args.dry_run:
        print("[dry-run] full-install would run (first-run=%s)" % args.first_run)
        return 0
    success = manager.full_installation(first_run=args.first_run)
    return 0 if success else 1


def run_force_reinstall(manager: HomebrewManager, args: argparse.Namespace) -> int:
    if not args.packages:
        print("Error: force-reinstall requires package names")
        return 1
    if args.dry_run:
        print(f"[dry-run] force-reinstall would process: {', '.join(args.packages)}")
        return 0
    success = manager.force_reinstall_packages(args.packages)
    return 0 if success else 1


def run_simple_reinstall(manager: HomebrewManager, args: argparse.Namespace) -> int:
    if not args.packages:
        print("Error: simple-reinstall requires package names")
        return 1
    if args.dry_run:
        print(f"[dry-run] simple-reinstall would process: {', '.join(args.packages)}")
        return 0
    success = manager.simple_reinstall_packages(args.packages)
    return 0 if success else 1


def run_check_outdated(manager: HomebrewManager, args: argparse.Namespace) -> int:
    if args.dry_run:
        print("[dry-run] check-outdated would evaluate installed packages")
        return 0
    outdated = manager.detect_outdated_source_builds()
    if not outdated:
        print("✅ No source-built packages have outdated dependencies")
        return 0

    print(f"⚠️  Found {len(outdated)} source-built packages with outdated dependencies:\n")
    for pkg in outdated:
        print(f"• {pkg['name']}")
        print(f"  {pkg['newer_deps_count']}/{pkg['total_deps']} dependencies are newer")
        if pkg['newer_deps'][:3]:
            print(f"  Examples: {', '.join(pkg['newer_deps'][:3])}")
        print()
    print("Run 'chezmoi-homebrew-manager rebuild-outdated' to rebuild them")
    return 1


def run_rebuild_outdated(manager: HomebrewManager, args: argparse.Namespace) -> int:
    if args.dry_run:
        print("[dry-run] rebuild-outdated would rebuild detected packages")
        return 0
    success = manager.rebuild_outdated_packages()
    return 0 if success else 1


COMMAND_HANDLERS = {
    "full-install": run_full_install,
    "force-reinstall": run_force_reinstall,
    "simple-reinstall": run_simple_reinstall,
    "check-outdated": run_check_outdated,
    "rebuild-outdated": run_rebuild_outdated,
}


def main() -> None:
    parser = build_parser()
    args = parser.parse_args()

    manager = HomebrewManager(args.packages_file, dry_run=args.dry_run)

    if args.config:
        manager.load_runtime_config(args.config)

    handler = COMMAND_HANDLERS.get(args.command)
    if handler is None:
        print(f"Unknown command: {args.command}")
        sys.exit(1)

    if args.dry_run:
        print(f"[dry-run] Executing command '{args.command}'")

    exit_code = handler(manager, args)
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
