#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#   "pyyaml",
#   "networkx",
# ]
# ///
"""
Comprehensive Homebrew manager for Chezmoi with full macOS installation logic.
Handles all complex Homebrew operations extracted from the bash template.
"""

import argparse
import json
import os
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

from homebrew_manager import PackagesHelper, RebuildService
from homebrew_manager.install import InstallService


class HomebrewManager:
    def __init__(self, packages_file: Optional[Path] = None, *, dry_run: bool = False):
        self.chezmoi_source_dir = Path(os.environ.get("CHEZMOI_SOURCE_DIR", os.getcwd()))
        self.packages_file = packages_file or (self.chezmoi_source_dir / ".chezmoidata" / "packages.yml")
        self.config: Dict[str, Any] = {}
        self._formulae_cache: Optional[Dict[str, Any]] = None
        self._packages_helper: Optional[PackagesHelper] = None
        self._rebuild_service: Optional[RebuildService] = None
        self._install_service: Optional[InstallService] = None
        self.dry_run = dry_run
    
    def _setup_environment(self) -> None:
        """Set up Homebrew environment based on configuration."""
        if not self.config:
            return
            
        # Update source directory from config if provided
        if "chezmoi_source_dir" in self.config:
            self.chezmoi_source_dir = Path(self.config["chezmoi_source_dir"])
            if not self.packages_file.parent.name == ".chezmoidata":
                self.packages_file = self.chezmoi_source_dir / ".chezmoidata" / "packages.yml"
        # Reset helpers that depend on configuration
        self._packages_helper = None
        self._rebuild_service = None
        self._install_service = None
    
    def load_runtime_config(self, config_json: str) -> None:
        """Load runtime configuration from JSON string."""
        try:
            self.config = json.loads(config_json)
            self._setup_environment()
        except json.JSONDecodeError as e:
            print(f"Error parsing runtime config JSON: {e}")
            sys.exit(1)
    
    def _get_brew_prefix(self) -> Optional[Path]:
        """Get Homebrew prefix."""
        try:
            result = subprocess.run(["brew", "--prefix"], capture_output=True, text=True, check=True)
            return Path(result.stdout.strip())
        except subprocess.CalledProcessError:
            return None
    
    def _is_alternative_homebrew(self) -> bool:
        """Check if this is an alternative Homebrew installation."""
        return self.config.get("homebrew_type") == "alternative"
    
    def _get_running_services(self) -> Dict[str, str]:
        """Get currently running brew services and their status."""
        try:
            result = subprocess.run(["brew", "services", "list"], 
                                  capture_output=True, text=True, check=True)
            
            services = {}
            for line in result.stdout.strip().split('\n')[1:]:  # Skip header
                if line:
                    parts = line.split()
                    if len(parts) >= 2:
                        service_name = parts[0]
                        status = parts[1]  # 'started', 'stopped', 'error', etc.
                        services[service_name] = status
            
            return services
            
        except subprocess.CalledProcessError as e:
            print(f"Warning: Could not get brew services list: {e}")
            return {}
    
    def _stop_service(self, service_name: str) -> bool:
        """Stop a brew service."""
        try:
            print(f"  Stopping service: {service_name}")
            subprocess.run(["brew", "services", "stop", service_name], 
                         check=True, capture_output=True)
            return True
        except subprocess.CalledProcessError:
            return False
    
    def _start_service(self, service_name: str) -> bool:
        """Start a brew service."""
        try:
            print(f"  Starting service: {service_name}")
            subprocess.run(["brew", "services", "start", service_name], 
                         check=True, capture_output=True)
            return True
        except subprocess.CalledProcessError as e:
            print(f"  Warning: Failed to start service {service_name}: {e}")
            return False
    
    def _restart_service(self, service_name: str) -> bool:
        """Restart a brew service."""
        try:
            print(f"  Restarting service: {service_name}")
            subprocess.run(["brew", "services", "restart", service_name], 
                         check=True, capture_output=True)
            return True
        except subprocess.CalledProcessError as e:
            print(f"  Warning: Failed to restart service {service_name}: {e}")
            return False
    
    def _get_all_formulae_info(self, force_refresh: bool = False) -> Dict[str, Any]:
        """Get cached formulae info, fetching if needed."""
        if self._formulae_cache is None or force_refresh:
            try:
                result = subprocess.run(["brew", "info", "--json=v2", "--installed"], 
                                      capture_output=True, text=True, check=True)
                data = json.loads(result.stdout)
                
                # Create a dictionary keyed by formula name for quick lookup
                self._formulae_cache = {}
                for formula in data['formulae']:
                    name = formula['name']
                    self._formulae_cache[name] = formula
                    # Also store by full name if different
                    if formula.get('full_name') and formula['full_name'] != name:
                        self._formulae_cache[formula['full_name']] = formula
                        
            except (subprocess.CalledProcessError, json.JSONDecodeError) as e:
                print(f"Error fetching formulae info: {e}")
                self._formulae_cache = {}
                
        return self._formulae_cache

    def _get_packages_helper(self) -> PackagesHelper:
        if self._packages_helper is None:
            self._packages_helper = PackagesHelper.load(
                self.packages_file,
                is_alternative=self._is_alternative_homebrew(),
            )
        return self._packages_helper

    def _get_rebuild_service(self) -> RebuildService:
        if self._rebuild_service is None:
            self._rebuild_service = RebuildService(
                get_formulae_info=self._get_all_formulae_info,
                packages_helper=self._get_packages_helper(),
                stop_service=self._stop_service,
                start_service=self._start_service,
                install_package=lambda pkg_config, reinstall=True: self.install_individual_package(
                    pkg_config, reinstall=reinstall
                ),
                dry_run=self.dry_run,
                is_alternative=self._is_alternative_homebrew,
            )
        return self._rebuild_service

    def _get_install_service(self) -> InstallService:
        if self._install_service is None:
            self._install_service = InstallService(self)
        return self._install_service

    def install_homebrew(self) -> bool:
        """Install Homebrew if not present."""
        return self._get_install_service().install_homebrew()
    
    def verify_formula_patches(self) -> bool:
        """Verify formula patches before applying."""
        return self._get_install_service().verify_formula_patches()
    
    def install_taps(self) -> bool:
        """Install Homebrew taps."""
        return self._get_install_service().install_taps()

    def classify_packages(self) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]], List[str]]:
        """Classify packages for installation strategy."""
        return self._get_install_service().classify_packages()

    def install_individual_packages(self, packages: List[Dict[str, Any]]) -> bool:
        """Install packages that need individual handling."""
        return self._get_install_service().install_individual_packages(packages)
    def force_reinstall_packages(self, packages: List[str]) -> bool:
        """Force reinstall packages with proper configuration from packages.yml."""
        if self.dry_run:
            print(f"[dry-run] Would force reinstall packages: {', '.join(packages)}")
        if not packages:
            print("No packages to reinstall")
            return False
        
        # Validate and clean package names
        valid_packages = []
        for pkg in packages:
            pkg = pkg.strip()
            if not pkg:
                continue
            if not all(c.isalnum() or c in '@+-_' for c in pkg):
                print(f"Warning: Invalid package name '{pkg}', skipping")
                continue
            valid_packages.append(pkg)
        
        if not valid_packages:
            print("No valid packages to reinstall")
            return False
        
        print(f"Force reinstalling packages: {', '.join(valid_packages)}")
        
        helper = self._get_packages_helper()
        
        # Sort packages by install order
        sorted_packages = sorted(
            valid_packages,
            key=lambda p: (helper.install_order(p), valid_packages.index(p)),
        )
        
        # Uninstall packages first
        print("Uninstalling packages for clean reinstall...")
        for pkg in sorted_packages:
            try:
                result = subprocess.run(["brew", "list", "--formula"], 
                                      capture_output=True, text=True, check=True)
                if pkg in result.stdout.splitlines():
                    print(f"Uninstalling {pkg}...")
                    subprocess.run(["brew", "uninstall", "--ignore-dependencies", pkg], check=True)
            except subprocess.CalledProcessError as e:
                print(f"Warning: Failed to uninstall {pkg}: {e}")
        
        # Reinstall packages with proper configuration
        print("Reinstalling packages with configuration...")
        for pkg in sorted_packages:
            if not self._install_single_package(pkg):
                print(f"Warning: Failed to reinstall {pkg}")
                return False
        
        return True
    
    def _install_single_package(self, package_name: str) -> bool:
        """Install a single package with its configuration from packages.yml."""
        return self._get_install_service().install_package_by_name(package_name)

    def detect_outdated_source_builds(self) -> List[Dict[str, Any]]:
        """Wrapper around the rebuild service detection."""
        return self._get_rebuild_service().detect_outdated()

    def rebuild_outdated_packages(self) -> bool:
        """Delegate rebuild execution to the rebuild service."""
        service = self._get_rebuild_service()
        outdated = service.detect_outdated()

        if not outdated:
            print("✅ No source-built packages need rebuilding")
            return True

        print(f"\n⚠️  Found {len(outdated)} source-built packages with outdated dependencies:")
        for pkg in outdated[:10]:
            print(f"  • {pkg['name']} ({pkg['newer_deps_count']}/{pkg['total_deps']} dependencies newer)")
        if len(outdated) > 10:
            print(f"  ... and {len(outdated) - 10} more")

        result = service.rebuild(outdated)

        if result.failed:
            print(f"\n❌ Failed to rebuild {len(result.failed)} packages: {', '.join(result.failed)}")
            print(f"✅ Successfully rebuilt {result.rebuilt} packages")
            return False

        print(f"\n✅ Successfully rebuilt all {result.rebuilt} packages")
        self._formulae_cache = None
        return True
    
    def install_individual_package(self, pkg_config: Dict[str, Any], reinstall: bool = False) -> bool:
        """Install a single package with its configuration."""
        return self._get_install_service().install_individual_package(pkg_config, reinstall=reinstall)

    def simple_reinstall_packages(self, packages: List[str]) -> bool:
        """Simple reinstall using brew reinstall (legacy CHEZMOI_REINSTALL_PACKAGES behavior)."""
        if self.dry_run:
            print(f"[dry-run] Would simple reinstall packages: {', '.join(packages)}")
        if not packages:
            print("No packages to reinstall")
            return False
        
        print(f"Simple reinstalling packages: {', '.join(packages)}")
        
        for pkg in packages:
            pkg = pkg.strip()
            if not pkg:
                continue
            
            try:
                # Check if package is installed
                result = subprocess.run(["brew", "list", "--formula"], 
                                      capture_output=True, text=True, check=True)
                if pkg in result.stdout.splitlines():
                    print(f"Reinstalling {pkg}...")
                    subprocess.run(["brew", "reinstall", pkg], check=True)
                else:
                    print(f"Package {pkg} not installed, installing...")
                    subprocess.run(["brew", "install", pkg], check=True)
            except subprocess.CalledProcessError as e:
                print(f"Error with {pkg}: {e}")
                return False
        
        return True

    def generate_brew_bundle(self, brews: List[Dict[str, Any]], casks: List[str]) -> str:
        """Generate brew bundle content."""
        return self._get_install_service().generate_brew_bundle(brews, casks)

    def install_with_bundle(self, bundle_content: str) -> bool:
        """Install packages using brew bundle."""
        return self._get_install_service().install_with_bundle(bundle_content)

    def setup_terminfo(self) -> bool:
        """Set up kitty TERMINFO for Emacs compatibility."""
        return self._get_install_service().setup_terminfo()

    def update_spotlight_index(self) -> bool:
        """Index ~/Applications for Spotlight (alternative Homebrew)."""
        return self._get_install_service().update_spotlight_index()

    def install_missing_packages_only(self) -> bool:
        """Install only missing packages (no upgrades)."""
        return self._get_install_service().install_missing_packages_only()
    def full_installation(self, first_run: bool = False) -> bool:
        """Perform full Homebrew installation process."""
        if self.dry_run:
            print("[dry-run] Starting full installation workflow")
        if first_run:
            print("Starting initial Homebrew setup...")
        else:
            print("Checking Homebrew packages...")
        
        # Install Homebrew if needed
        if not self.install_homebrew():
            return False
        
        # Set environment variables for alternative Homebrew
        if self._is_alternative_homebrew():
            os.environ["HOMEBREW_NO_INSTALL_FROM_API"] = "1"
            print("Set HOMEBREW_NO_INSTALL_FROM_API=1 to use local formula modifications")
        
        # Verify formula patches
        if not self.verify_formula_patches():
            return False
        
        # Apply formula patches (placeholder - would need template integration)
        # This is where the patch-homebrew-formulas template would be called
        
        # Install taps
        if not self.install_taps():
            return False
        
        if first_run:
            # First run: Install all packages
            print("\nPerforming initial package installation...")
            
            # Classify and install packages
            individual_brews, bundle_brews, casks = self.classify_packages()

            # Sort by install_order (then by original position for stability)
            def _pkg_name(p):
                return p.get("name") if isinstance(p, dict) else p
            individual_brews = sorted(
                list(enumerate(individual_brews)),
                key=lambda t: (self._get_install_order(_pkg_name(t[1])), t[0])
            )
            individual_brews = [p for _, p in individual_brews]

            bundle_brews = sorted(
                list(enumerate(bundle_brews)),
                key=lambda t: (self._get_install_order(_pkg_name(t[1])), t[0])
            )
            bundle_brews = [p for _, p in bundle_brews]
            
            # Install packages with environment variables first
            if not self.install_individual_packages(individual_brews):
                return False
            
            # Install remaining packages with brew bundle
            bundle_content = self.generate_brew_bundle(bundle_brews, casks)
            if not self.install_with_bundle(bundle_content):
                return False
        else:
            # Subsequent runs: Check for outdated packages first, then install missing
            print("\nChecking for package updates...")
            
            # Check for and rebuild outdated source-built packages
            # This is non-critical - don't fail the entire installation if rebuilds fail
            print("\nChecking for outdated source-built packages...")
            try:
                outdated = self.detect_outdated_source_builds()
                if outdated:
                    print(f"Found {len(outdated)} packages that need rebuilding due to dependency updates")
                    if not self.rebuild_outdated_packages():
                        print("⚠️  Some packages failed to rebuild, but installation continues")
                        print("  Run 'brew-check-outdated' manually to retry")
            except Exception as e:
                print(f"⚠️  Warning: Could not check for outdated packages: {e}")
                print("  Run 'brew-check-outdated' manually to check")
            
            # Now install any missing packages
            if not self.install_missing_packages_only():
                return False
        
        # Set up kitty TERMINFO
        if not self.setup_terminfo():
            return False
        
        # Update Spotlight index
        if not self.update_spotlight_index():
            return False
        
        # Update homebrew state file for alternative installations
        if self._is_alternative_homebrew():
            try:
                subprocess.run(["bash", "-c", "update_homebrew_state"], check=False)
                print("Updated homebrew state file")
            except Exception as e:
                print(f"Warning: Failed to update homebrew state: {e}")
        
        # Check for and rebuild outdated source-built packages
        # This is non-critical - don't fail the entire installation if rebuilds fail
        print("\nChecking for outdated source-built packages...")
        try:
            outdated = self.detect_outdated_source_builds()
            if outdated:
                print(f"Found {len(outdated)} packages that need rebuilding due to dependency updates")
                if not self.rebuild_outdated_packages():
                    print("⚠️  Some packages failed to rebuild, but installation continues")
                    print("  Run 'brew-check-outdated' manually to retry")
        except Exception as e:
            print(f"⚠️  Warning: Could not check for outdated packages: {e}")
            print("  Run 'brew-check-outdated' manually to check")
        
        print("✅ Full Homebrew installation completed successfully!")
        return True


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Comprehensive Homebrew manager for Chezmoi"
    )
    parser.add_argument(
        "command",
        choices=[
            "full-install",
            "force-reinstall",
            "simple-reinstall",
            "check-outdated",
            "rebuild-outdated",
        ],
        help="Command to execute",
    )
    parser.add_argument(
        "--config",
        help="Runtime configuration as JSON string",
    )
    parser.add_argument(
        "--packages-file",
        type=Path,
        help="Override path to packages.yml file",
    )
    parser.add_argument(
        "--first-run",
        action="store_true",
        help="Indicate this is the first run (install all packages)",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show planned actions without executing them",
    )
    parser.add_argument(
        "packages",
        nargs="*",
        help="Packages for force-reinstall or simple-reinstall commands",
    )
    return parser


def run_full_install(manager: HomebrewManager, args: argparse.Namespace) -> int:
    if args.dry_run:
        print("[dry-run] full-install would run (first-run=%s)" % args.first_run)
        return 0
    success = manager.full_installation(first_run=args.first_run)
    return 0 if success else 1


def run_force_reinstall(manager: HomebrewManager, args: argparse.Namespace) -> int:
    if not args.packages:
        print("Error: force-reinstall requires package names")
        return 1
    if args.dry_run:
        print(f"[dry-run] force-reinstall would process: {', '.join(args.packages)}")
        return 0
    success = manager.force_reinstall_packages(args.packages)
    return 0 if success else 1


def run_simple_reinstall(manager: HomebrewManager, args: argparse.Namespace) -> int:
    if not args.packages:
        print("Error: simple-reinstall requires package names")
        return 1
    if args.dry_run:
        print(f"[dry-run] simple-reinstall would process: {', '.join(args.packages)}")
        return 0
    success = manager.simple_reinstall_packages(args.packages)
    return 0 if success else 1


def run_check_outdated(manager: HomebrewManager, args: argparse.Namespace) -> int:
    if args.dry_run:
        print("[dry-run] check-outdated would evaluate installed packages")
        return 0
    outdated = manager.detect_outdated_source_builds()
    if not outdated:
        print("✅ No source-built packages have outdated dependencies")
        return 0

    print(f"⚠️  Found {len(outdated)} source-built packages with outdated dependencies:\n")
    for pkg in outdated:
        print(f"• {pkg['name']}")
        print(f"  {pkg['newer_deps_count']}/{pkg['total_deps']} dependencies are newer")
        if pkg['newer_deps'][:3]:
            print(f"  Examples: {', '.join(pkg['newer_deps'][:3])}")
        print()
    print("Run 'chezmoi-homebrew-manager rebuild-outdated' to rebuild them")
    return 1


def run_rebuild_outdated(manager: HomebrewManager, args: argparse.Namespace) -> int:
    if args.dry_run:
        print("[dry-run] rebuild-outdated would rebuild detected packages")
        return 0
    success = manager.rebuild_outdated_packages()
    return 0 if success else 1


COMMAND_HANDLERS = {
    "full-install": run_full_install,
    "force-reinstall": run_force_reinstall,
    "simple-reinstall": run_simple_reinstall,
    "check-outdated": run_check_outdated,
    "rebuild-outdated": run_rebuild_outdated,
}


def main() -> None:
    parser = build_parser()
    args = parser.parse_args()

    manager = HomebrewManager(args.packages_file, dry_run=args.dry_run)

    if args.config:
        manager.load_runtime_config(args.config)

    handler = COMMAND_HANDLERS.get(args.command)
    if handler is None:
        print(f"Unknown command: {args.command}")
        sys.exit(1)

    if args.dry_run:
        print(f"[dry-run] Executing command '{args.command}'")

    exit_code = handler(manager, args)
    sys.exit(exit_code)


if __name__ == "__main__":
    main()
