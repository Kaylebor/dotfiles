#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#   "pyyaml",
#   "networkx",
# ]
# ///
"""
Comprehensive Homebrew manager for Chezmoi with full macOS installation logic.
Handles all complex Homebrew operations extracted from the bash template.
"""

import argparse
import json
import os
import subprocess
import sys
import yaml
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple, Set
from math import inf
import networkx as nx


class HomebrewManager:
    def __init__(self, packages_file: Optional[Path] = None):
        self.chezmoi_source_dir = Path(os.environ.get("CHEZMOI_SOURCE_DIR", os.getcwd()))
        self.packages_file = packages_file or (self.chezmoi_source_dir / ".chezmoidata" / "packages.yml")
        self.config: Dict[str, Any] = {}
        self._formulae_cache: Optional[Dict[str, Any]] = None
    
    def _setup_environment(self) -> None:
        """Set up Homebrew environment based on configuration."""
        if not self.config:
            return
            
        # Update source directory from config if provided
        if "chezmoi_source_dir" in self.config:
            self.chezmoi_source_dir = Path(self.config["chezmoi_source_dir"])
            if not self.packages_file.parent.name == ".chezmoidata":
                self.packages_file = self.chezmoi_source_dir / ".chezmoidata" / "packages.yml"
    
    def load_runtime_config(self, config_json: str) -> None:
        """Load runtime configuration from JSON string."""
        try:
            self.config = json.loads(config_json)
            self._setup_environment()
        except json.JSONDecodeError as e:
            print(f"Error parsing runtime config JSON: {e}")
            sys.exit(1)
    
    def _get_brew_prefix(self) -> Optional[Path]:
        """Get Homebrew prefix."""
        try:
            result = subprocess.run(["brew", "--prefix"], capture_output=True, text=True, check=True)
            return Path(result.stdout.strip())
        except subprocess.CalledProcessError:
            return None
    
    def _is_alternative_homebrew(self) -> bool:
        """Check if this is an alternative Homebrew installation."""
        return self.config.get("homebrew_type") == "alternative"
    
    def _get_running_services(self) -> Dict[str, str]:
        """Get currently running brew services and their status."""
        try:
            result = subprocess.run(["brew", "services", "list"], 
                                  capture_output=True, text=True, check=True)
            
            services = {}
            for line in result.stdout.strip().split('\n')[1:]:  # Skip header
                if line:
                    parts = line.split()
                    if len(parts) >= 2:
                        service_name = parts[0]
                        status = parts[1]  # 'started', 'stopped', 'error', etc.
                        services[service_name] = status
            
            return services
            
        except subprocess.CalledProcessError as e:
            print(f"Warning: Could not get brew services list: {e}")
            return {}
    
    def _stop_service(self, service_name: str) -> bool:
        """Stop a brew service."""
        try:
            print(f"  Stopping service: {service_name}")
            subprocess.run(["brew", "services", "stop", service_name], 
                         check=True, capture_output=True)
            return True
        except subprocess.CalledProcessError:
            return False
    
    def _start_service(self, service_name: str) -> bool:
        """Start a brew service."""
        try:
            print(f"  Starting service: {service_name}")
            subprocess.run(["brew", "services", "start", service_name], 
                         check=True, capture_output=True)
            return True
        except subprocess.CalledProcessError as e:
            print(f"  Warning: Failed to start service {service_name}: {e}")
            return False
    
    def _restart_service(self, service_name: str) -> bool:
        """Restart a brew service."""
        try:
            print(f"  Restarting service: {service_name}")
            subprocess.run(["brew", "services", "restart", service_name], 
                         check=True, capture_output=True)
            return True
        except subprocess.CalledProcessError as e:
            print(f"  Warning: Failed to restart service {service_name}: {e}")
            return False
    
    def _get_all_formulae_info(self, force_refresh: bool = False) -> Dict[str, Any]:
        """Get cached formulae info, fetching if needed."""
        if self._formulae_cache is None or force_refresh:
            try:
                result = subprocess.run(["brew", "info", "--json=v2", "--installed"], 
                                      capture_output=True, text=True, check=True)
                data = json.loads(result.stdout)
                
                # Create a dictionary keyed by formula name for quick lookup
                self._formulae_cache = {}
                for formula in data['formulae']:
                    name = formula['name']
                    self._formulae_cache[name] = formula
                    # Also store by full name if different
                    if formula.get('full_name') and formula['full_name'] != name:
                        self._formulae_cache[formula['full_name']] = formula
                        
            except (subprocess.CalledProcessError, json.JSONDecodeError) as e:
                print(f"Error fetching formulae info: {e}")
                self._formulae_cache = {}
                
        return self._formulae_cache

    def _get_install_order(self, package_name: str) -> float:
        """Return install_order for a package, or +inf if not specified.

        Honors alternative_only.install_order when running in alternative Homebrew mode.
        """
        packages_config = self._load_packages_config()
        brews = packages_config.get("packages", {}).get("darwin", {}).get("brews", [])
        for pkg in brews:
            if isinstance(pkg, dict) and pkg.get("name") == package_name:
                if "install_order" in pkg:
                    try:
                        return float(pkg["install_order"])
                    except Exception:
                        return float("inf")
                if (self._is_alternative_homebrew() and
                    "alternative_only" in pkg and
                    isinstance(pkg["alternative_only"], dict) and
                    "install_order" in pkg["alternative_only"]):
                    try:
                        return float(pkg["alternative_only"]["install_order"])
                    except Exception:
                        return float("inf")
                return float("inf")
        return float("inf")
    
    def _load_packages_config(self) -> Dict[str, Any]:
        """Load packages configuration from packages.yml."""
        if not self.packages_file.exists():
            print(f"Warning: Packages file not found: {self.packages_file}")
            return {}
        
        try:
            with open(self.packages_file, 'r') as f:
                return yaml.safe_load(f) or {}
        except Exception as e:
            print(f"Error loading packages config: {e}")
            return {}
    
    def install_homebrew(self) -> bool:
        """Install Homebrew if not present."""
        if self.config.get("has_brew"):
            return True
        
        print("Installing Homebrew...")
        
        if self._is_alternative_homebrew():
            # Alternative installation
            homebrew_path = self.config.get("homebrew_path", "homebrew")
            tarball_url = self.config.get("homebrew_tarball_url")
            
            if not tarball_url:
                print("Error: Missing homebrew_tarball_url in config")
                return False
            
            print(f"Installing Homebrew to {homebrew_path} for MDM compatibility...")
            
            home_dir = Path.home()
            homebrew_dir = home_dir / homebrew_path
            
            try:
                homebrew_dir.mkdir(parents=True, exist_ok=True)
                
                # Download and extract
                cmd = f'curl -L {tarball_url} | tar xz --strip-components 1 -C "{homebrew_dir}"'
                subprocess.run(cmd, shell=True, check=True)
                
                # Set up environment
                brew_env_cmd = f"{homebrew_dir}/bin/brew shellenv"
                result = subprocess.run(brew_env_cmd, shell=True, capture_output=True, text=True, check=True)
                
                # Apply environment to current process
                for line in result.stdout.strip().split('\n'):
                    if line.startswith('export '):
                        key_value = line[7:]  # Remove 'export '
                        if '=' in key_value:
                            key, value = key_value.split('=', 1)
                            value = value.strip('"\'')
                            os.environ[key] = value
                
                # Update and fix permissions
                subprocess.run(["brew", "update", "--force", "--quiet"], check=True)
                
                brew_bin = self.config.get("brew_bin")
                if brew_bin:
                    zsh_dir = Path(subprocess.run([brew_bin, "--prefix"], capture_output=True, text=True, check=True).stdout.strip()) / "share" / "zsh"
                    if zsh_dir.exists():
                        subprocess.run(["chmod", "-R", "go-w", str(zsh_dir)], check=False)
                
                return True
                
            except subprocess.CalledProcessError as e:
                print(f"Error installing alternative Homebrew: {e}")
                return False
        else:
            # Standard installation
            install_url = self.config.get("homebrew_install_url", "https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh")
            
            try:
                cmd = f'/bin/bash -c "$(curl -fsSL {install_url})"'
                subprocess.run(cmd, shell=True, check=True)
                return True
            except subprocess.CalledProcessError as e:
                print(f"Error installing standard Homebrew: {e}")
                return False
    
    def verify_formula_patches(self) -> bool:
        """Verify formula patches before applying."""
        if not self._is_alternative_homebrew():
            return True
        
        packages_config = self._load_packages_config()
        formula_patches = packages_config.get("formula_patches", {})
        
        if not formula_patches:
            return True
        
        print("Verifying formula patches for alternative Homebrew...")
        
        for formula, patch_config in formula_patches.items():
            # Skip if package is already installed
            result = subprocess.run(["brew", "list", formula], capture_output=True)
            if result.returncode == 0:
                continue
            
            # If no expected_hash is set and there is no corresponding patch file, skip hash verification
            expected_hash = (patch_config or {}).get("expected_hash")
            patch_file_path = self.chezmoi_source_dir / "scripts" / "patches" / f"{formula}.patch"
            if not expected_hash and not patch_file_path.exists():
                print(f"Skipping hash check for {formula} (no expected_hash and no patch file)")
                continue

            print(f"Verifying {formula} formula hash...")
            
            # Get formula path
            try:
                repo_result = subprocess.run(["brew", "--repository", "homebrew/core"], 
                                           capture_output=True, text=True, check=True)
                repo_path = Path(repo_result.stdout.strip())
                formula_path = repo_path / "Formula" / formula[0] / f"{formula}.rb"
                
                if not formula_path.exists():
                    print(f"⚠️  Formula not found: {formula_path}")
                    continue
                
                # Calculate actual hash
                result = subprocess.run(["shasum", "-a", "256", str(formula_path)], 
                                      capture_output=True, text=True, check=True)
                actual_hash = result.stdout.split()[0]
                
                if actual_hash != expected_hash:
                    print(f"❌ Hash mismatch for {formula}!")
                    print(f"   Expected: {expected_hash}")
                    print(f"   Actual:   {actual_hash}")
                    print(f"   Description: {patch_config.get('description', 'No description')}")
                    
                    issue_url = patch_config.get("issue_url")
                    if issue_url:
                        print(f"   Related issue: {issue_url}")
                    
                    print("   The formula may have been updated upstream.")
                    print("   Please update the patch and expected hash.")
                    return False
                else:
                    print(f"✅ {formula} formula hash verified")
                    print(f"   Patch: {patch_config.get('description', 'No description')}")
                    
            except subprocess.CalledProcessError as e:
                print(f"Error verifying formula {formula}: {e}")
                return False
        
        return True
    
    def install_taps(self) -> bool:
        """Install Homebrew taps."""
        packages_config = self._load_packages_config()
        taps = packages_config.get("packages", {}).get("darwin", {}).get("taps", [])
        
        if not taps:
            return True
        
        print("Installing Homebrew taps...")
        for tap in taps:
            try:
                print(f"Tapping {tap}...")
                subprocess.run(["brew", "tap", tap], check=True)
            except subprocess.CalledProcessError as e:
                print(f"Error tapping {tap}: {e}")
                return False
        
        return True
    
    def classify_packages(self) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]], List[str]]:
        """Classify packages for installation strategy."""
        packages_config = self._load_packages_config()
        brews = packages_config.get("packages", {}).get("darwin", {}).get("brews", [])
        casks = packages_config.get("packages", {}).get("darwin", {}).get("casks", [])
        
        # Classify brews
        individual_brews = []  # Packages needing individual installation (with env vars)
        bundle_brews = []      # Packages for brew bundle
        
        for pkg in brews:
            if isinstance(pkg, str):
                bundle_brews.append({"name": pkg, "type": "string"})
            elif isinstance(pkg, dict):
                # Check if package needs individual installation
                has_env = "env" in pkg
                has_alt_env = (self._is_alternative_homebrew() and 
                              "alternative_only" in pkg and 
                              "env" in pkg["alternative_only"])
                
                if has_env or has_alt_env:
                    individual_brews.append(pkg)
                else:
                    bundle_brews.append(pkg)
        
        # Process casks with skip conditions
        processed_casks = []
        for cask in casks:
            if isinstance(cask, str):
                processed_casks.append(cask)
            elif isinstance(cask, dict):
                # Handle skip_if_installed logic
                skip_paths = cask.get("skip_if_installed", [])
                if skip_paths:
                    should_skip = False
                    
                    if isinstance(skip_paths, list):
                        for path in skip_paths:
                            expanded_path = Path(path).expanduser()
                            if expanded_path.exists():
                                should_skip = True
                                break
                    else:
                        expanded_path = Path(skip_paths).expanduser()
                        if expanded_path.exists():
                            should_skip = True
                    
                    if not should_skip:
                        processed_casks.append(cask["name"])
                else:
                    processed_casks.append(cask["name"])
        
        return individual_brews, bundle_brews, processed_casks
    
    def install_individual_packages(self, packages: List[Dict[str, Any]]) -> bool:
        """Install packages that need individual handling (environment variables)."""
        if not packages:
            return True
        
        print("Installing packages with isolated environments...")
        
        for pkg in packages:
            pkg_name = pkg.get("name")
            if not pkg_name:
                continue
            
            print(f"Installing {pkg_name} with isolated environment...")
            
            # Build environment
            env = os.environ.copy()
            
            # Apply base environment variables
            if "env" in pkg:
                env.update(pkg["env"])
                print(f"Applied environment variables: {pkg['env']}")
            
            # Apply alternative-only environment variables
            if (self._is_alternative_homebrew() and 
                "alternative_only" in pkg and 
                "env" in pkg["alternative_only"]):
                env.update(pkg["alternative_only"]["env"])
                print(f"Applied alternative environment variables: {pkg['alternative_only']['env']}")
            
            # Build command
            cmd = ["brew", "install", pkg_name]

            # Add arguments
            if "args" in pkg:
                for arg in pkg["args"]:
                    cmd.append(f"--{arg}")

            # Add alternative-only arguments
            if (self._is_alternative_homebrew() and
                "alternative_only" in pkg and
                "args" in pkg["alternative_only"]):
                for arg in pkg["alternative_only"]["args"]:
                    cmd.append(f"--{arg}")

            try:
                subprocess.run(cmd, env=env, check=True)
                print(f"✅ Successfully installed {pkg_name}")
            except subprocess.CalledProcessError as e:
                print(f"❌ Error installing {pkg_name}: {e}")
                return False
        
        return True
    
    def force_reinstall_packages(self, packages: List[str]) -> bool:
        """Force reinstall packages with proper configuration from packages.yml."""
        if not packages:
            print("No packages to reinstall")
            return False
        
        # Validate and clean package names
        valid_packages = []
        for pkg in packages:
            pkg = pkg.strip()
            if not pkg:
                continue
            if not all(c.isalnum() or c in '@+-_' for c in pkg):
                print(f"Warning: Invalid package name '{pkg}', skipping")
                continue
            valid_packages.append(pkg)
        
        if not valid_packages:
            print("No valid packages to reinstall")
            return False
        
        print(f"Force reinstalling packages: {', '.join(valid_packages)}")
        
        # Get package configurations for sorting
        packages_config = self._load_packages_config()
        brews = packages_config.get("packages", {}).get("darwin", {}).get("brews", [])
        
        def get_install_order(package_name: str) -> float:
            """Get install order for package, returns inf if not specified."""
            for pkg in brews:
                if isinstance(pkg, dict) and pkg.get('name') == package_name:
                    # Check top-level install_order first
                    if 'install_order' in pkg:
                        return float(pkg['install_order'])
                    # Check alternative_only install_order
                    if (self._is_alternative_homebrew() and 
                        'alternative_only' in pkg and 
                        'install_order' in pkg['alternative_only']):
                        return float(pkg['alternative_only']['install_order'])
            return float('inf')
        
        # Sort packages by install order
        sorted_packages = sorted(valid_packages, key=lambda p: (get_install_order(p), valid_packages.index(p)))
        
        # Uninstall packages first
        print("Uninstalling packages for clean reinstall...")
        for pkg in sorted_packages:
            try:
                result = subprocess.run(["brew", "list", "--formula"], 
                                      capture_output=True, text=True, check=True)
                if pkg in result.stdout.splitlines():
                    print(f"Uninstalling {pkg}...")
                    subprocess.run(["brew", "uninstall", "--ignore-dependencies", pkg], check=True)
            except subprocess.CalledProcessError as e:
                print(f"Warning: Failed to uninstall {pkg}: {e}")
        
        # Reinstall packages with proper configuration
        print("Reinstalling packages with configuration...")
        for pkg in sorted_packages:
            if not self._install_single_package(pkg):
                print(f"Warning: Failed to reinstall {pkg}")
                return False
        
        return True
    
    def _install_single_package(self, package_name: str) -> bool:
        """Install a single package with its configuration from packages.yml."""
        packages_config = self._load_packages_config()
        brews = packages_config.get("packages", {}).get("darwin", {}).get("brews", [])
        
        # Find package configuration
        pkg_config = None
        for pkg in brews:
            if isinstance(pkg, dict) and pkg.get('name') == package_name:
                pkg_config = pkg
                break
            elif isinstance(pkg, str) and pkg == package_name:
                pkg_config = {'name': pkg}
                break
        
        if not pkg_config:
            # Package not in config, install with defaults
            print(f"Installing {package_name} (not in config)")
            try:
                subprocess.run(["brew", "install", package_name], check=True)
                return True
            except subprocess.CalledProcessError as e:
                print(f"Error installing {package_name}: {e}")
                return False
        
        # Install with configuration
        return self.install_individual_package(pkg_config)

    def detect_outdated_source_builds(self) -> List[Dict[str, Any]]:
        """Detect source-built packages with newer dependencies using cached data."""
        formulae = self._get_all_formulae_info()
        
        if not formulae:
            return []
        
        # Create a map of all package install times
        install_times = {}
        for name, formula in formulae.items():
            if 'installed' in formula and formula['installed']:
                install_times[name] = formula['installed'][0].get('time')
        
        # Find source-built packages with outdated dependencies
        outdated_packages = []
        seen = set()  # Track packages we've already processed
        
        for name, formula in formulae.items():
            # Skip if we've already seen this package (avoid duplicates from full_name)
            if formula['name'] in seen:
                continue
            seen.add(formula['name'])
            
            if 'installed' in formula and formula['installed'] and not formula['installed'][0]['built_as_bottle']:
                pkg_name = formula['name']
                pkg_time = formula['installed'][0].get('time')
                
                if not pkg_time:
                    continue
                
                # Check dependencies
                deps = formula['installed'][0].get('runtime_dependencies', [])
                newer_deps = []
                
                for dep in deps:
                    dep_name = dep['full_name']
                    dep_time = install_times.get(dep_name)
                    
                    if dep_time and dep_time > pkg_time:
                        newer_deps.append(dep_name)
                
                if newer_deps:
                    outdated_packages.append({
                        'name': pkg_name,
                        'pkg_time': pkg_time,
                        'newer_deps': newer_deps,
                        'newer_deps_count': len(newer_deps),
                        'total_deps': len(deps)
                    })
        
        # Sort by number of newer dependencies
        outdated_packages.sort(key=lambda x: x['newer_deps_count'], reverse=True)
        
        return outdated_packages
    
    def _get_rebuild_order(self, packages_to_rebuild: Set[str]) -> List[str]:
        """Get the order to rebuild packages using topological sort to handle dependencies."""
        formulae = self._get_all_formulae_info()
        
        # Build a dependency graph for source-built packages
        G = nx.DiGraph()
        
        # Add all source-built packages as nodes
        source_built_packages = set()
        for name, formula in formulae.items():
            if 'installed' in formula and formula['installed'] and not formula['installed'][0]['built_as_bottle']:
                pkg_name = formula['name']
                source_built_packages.add(pkg_name)
                G.add_node(pkg_name)
        
        # Add edges (package -> dependency means package depends on dependency)
        for name, formula in formulae.items():
            if 'installed' not in formula or not formula['installed']:
                continue
            if formula['installed'][0]['built_as_bottle']:
                continue
                
            pkg_name = formula['name']
            if pkg_name not in source_built_packages:
                continue
                
            deps = formula['installed'][0].get('runtime_dependencies', [])
            for dep in deps:
                dep_name = dep.get('full_name', '')
                # Check if the dependency is also a source-built package
                if dep_name in formulae and dep_name in source_built_packages:
                    # Add edge: pkg_name depends on dep_name
                    G.add_edge(pkg_name, dep_name)
        
        # Check for circular dependencies
        try:
            cycles = list(nx.simple_cycles(G))
            if cycles:
                print(f"⚠️  Warning: Circular dependencies detected:")
                for cycle in cycles[:3]:  # Show first 3 cycles
                    print(f"    {' -> '.join(cycle + [cycle[0]])}")
                if len(cycles) > 3:
                    print(f"    ... and {len(cycles) - 3} more cycles")
                print("  Breaking cycles by ignoring back-edges...")
                
                # Remove cycles by converting to DAG
                # This is a simple approach - just break cycles by removing back edges
                G = nx.DiGraph(nx.dag.transitive_reduction(G))
        except nx.NetworkXError:
            pass  # Graph might already be acyclic
        
        # Get packages that need rebuilding and all their dependents
        packages_affected = set(packages_to_rebuild)
        
        # Find all packages that depend on the packages we're rebuilding
        for pkg in packages_to_rebuild:
            if pkg in G:
                # Get all nodes that have a path to this package (ancestors in dependency tree)
                ancestors = nx.ancestors(G, pkg)
                packages_affected.update(ancestors)
        
        # Create subgraph with only affected packages
        subgraph = G.subgraph(packages_affected)
        
        # Topological sort to get rebuild order (reverse because we want dependencies first)
        try:
            rebuild_order = list(nx.topological_sort(subgraph))
            rebuild_order.reverse()  # Build dependencies before dependents
        except nx.NetworkXUnfeasible:
            # This shouldn't happen after we removed cycles, but just in case
            print("⚠️  Warning: Could not determine dependency order, using original order")
            rebuild_order = list(packages_affected)
        
        return rebuild_order
    
    def rebuild_outdated_packages(self) -> bool:
        """Detect and rebuild outdated source-built packages with proper dependency ordering."""
        outdated = self.detect_outdated_source_builds()
        
        if not outdated:
            print("✅ No source-built packages need rebuilding")
            return True
        
        print(f"\n⚠️  Found {len(outdated)} source-built packages with outdated dependencies:")
        for pkg in outdated[:10]:  # Show first 10
            print(f"  • {pkg['name']} ({pkg['newer_deps_count']}/{pkg['total_deps']} dependencies newer)")
        if len(outdated) > 10:
            print(f"  ... and {len(outdated) - 10} more")
        
        # Get the packages that need rebuilding
        packages_to_rebuild = {pkg['name'] for pkg in outdated}
        
        # Get proper rebuild order considering dependencies
        print("\nAnalyzing dependency graph...")
        rebuild_order = self._get_rebuild_order(packages_to_rebuild)
        
        if len(rebuild_order) > len(packages_to_rebuild):
            additional = len(rebuild_order) - len(packages_to_rebuild)
            print(f"  Including {additional} additional packages that depend on outdated packages")
        
        # Get currently running services that we'll need to manage
        print("\nChecking for running services...")
        running_services = self._get_running_services()
        services_to_restart = {}
        
        for pkg_name in rebuild_order:
            if pkg_name in running_services and running_services[pkg_name] in ['started', 'running']:
                services_to_restart[pkg_name] = running_services[pkg_name]
                print(f"  Found running service: {pkg_name}")
        
        if services_to_restart:
            print(f"\nWill manage {len(services_to_restart)} service(s) during rebuild")
        
        print(f"\nRebuilding {len(rebuild_order)} packages in dependency order...")
        
        # Get package configurations
        packages_config = self._load_packages_config()
        brews = packages_config.get("packages", {}).get("darwin", {}).get("brews", [])
        
        # Create a map for quick lookup
        pkg_configs = {}
        for pkg in brews:
            if isinstance(pkg, dict):
                pkg_configs[pkg.get('name')] = pkg
            elif isinstance(pkg, str):
                pkg_configs[pkg] = {'name': pkg}
        
        # Rebuild packages in order
        failed_packages = []
        rebuilt_count = 0
        
        for pkg_name in rebuild_order:
            print(f"\n[{rebuilt_count + 1}/{len(rebuild_order)}] Rebuilding {pkg_name}...")
            
            # Stop service if it's running
            if pkg_name in services_to_restart:
                self._stop_service(pkg_name)
            
            # Get package configuration to check for special flags
            pkg_config = pkg_configs.get(pkg_name, {'name': pkg_name})
            
            # Check if this package requires force reinstall (uninstall first)
            # This can be set in packages.yml with force_reinstall: true
            force_reinstall = False
            if isinstance(pkg_config, dict):
                force_reinstall = pkg_config.get('force_reinstall', False)
                # Also check alternative_only section
                if self._is_alternative_homebrew() and 'alternative_only' in pkg_config:
                    force_reinstall = pkg_config['alternative_only'].get('force_reinstall', force_reinstall)
            
            # Some packages always need force reinstall
            if pkg_name in ['emacs-plus@31', 'emacs-plus@30', 'emacs-plus@29']:
                force_reinstall = True
                print(f"  Note: {pkg_name} always uses force reinstall")
            
            if force_reinstall:
                # Uninstall first for clean reinstall
                try:
                    subprocess.run(["brew", "uninstall", "--ignore-dependencies", pkg_name], 
                                 check=True, capture_output=True)
                    print(f"  Uninstalled {pkg_name} for clean reinstall")
                except subprocess.CalledProcessError:
                    print(f"  Warning: Failed to uninstall {pkg_name}, continuing anyway...")
            
            # Reinstall with configuration
            # Use reinstall=True unless we did a force reinstall (uninstall first)
            if self.install_individual_package(pkg_config, reinstall=(not force_reinstall)):
                rebuilt_count += 1
                
                # Restart service if it was running
                if pkg_name in services_to_restart:
                    self._start_service(pkg_name)
            else:
                failed_packages.append(pkg_name)
                print(f"  ❌ Failed to rebuild {pkg_name}")
                # Continue trying other packages
        
        # Clear the cache since we've modified installed packages
        self._formulae_cache = None
        
        # Check final service status
        if services_to_restart:
            print("\nChecking service status after rebuild:")
            final_services = self._get_running_services()
            for pkg_name in services_to_restart:
                if pkg_name in final_services:
                    status = final_services[pkg_name]
                    if status in ['started', 'running']:
                        print(f"  ✅ {pkg_name} service is running")
                    else:
                        print(f"  ⚠️  {pkg_name} service status: {status}")
                else:
                    print(f"  ❌ {pkg_name} service not found")
        
        if failed_packages:
            print(f"\n❌ Failed to rebuild {len(failed_packages)} packages: {', '.join(failed_packages)}")
            print(f"✅ Successfully rebuilt {rebuilt_count} packages")
            return False
        else:
            print(f"\n✅ Successfully rebuilt all {rebuilt_count} packages")
            return True
    
    def install_individual_package(self, pkg_config: Dict[str, Any], reinstall: bool = False) -> bool:
        """Install a single package with its configuration."""
        pkg_name = pkg_config.get("name") if isinstance(pkg_config, dict) else pkg_config
        if not pkg_name:
            return False
        
        action = "Reinstalling" if reinstall else "Installing"
        print(f"  {action} {pkg_name}...")
        
        # Build environment
        env = os.environ.copy()
        
        if isinstance(pkg_config, dict):
            # Apply base environment variables
            if "env" in pkg_config:
                env.update(pkg_config["env"])
                print(f"    With env: {pkg_config['env']}")
            
            # Apply alternative-only environment variables
            if (self._is_alternative_homebrew() and 
                "alternative_only" in pkg_config and 
                "env" in pkg_config["alternative_only"]):
                env.update(pkg_config["alternative_only"]["env"])
                print(f"    With alt env: {pkg_config['alternative_only']['env']}")
        
        # Build command
        cmd = ["brew", "reinstall" if reinstall else "install", pkg_name]

        if isinstance(pkg_config, dict):
            # Add arguments
            if "args" in pkg_config:
                for arg in pkg_config["args"]:
                    cmd.append(f"--{arg}")

            # Add alternative-only arguments
            if (self._is_alternative_homebrew() and
                "alternative_only" in pkg_config and
                "args" in pkg_config["alternative_only"]):
                for arg in pkg_config["alternative_only"]["args"]:
                    cmd.append(f"--{arg}")

        try:
            subprocess.run(cmd, env=env, check=True)
            return True
        except subprocess.CalledProcessError as e:
            print(f"    Error: {e}")
            return False
    
    def simple_reinstall_packages(self, packages: List[str]) -> bool:
        """Simple reinstall using brew reinstall (legacy CHEZMOI_REINSTALL_PACKAGES behavior)."""
        if not packages:
            print("No packages to reinstall")
            return False
        
        print(f"Simple reinstalling packages: {', '.join(packages)}")
        
        for pkg in packages:
            pkg = pkg.strip()
            if not pkg:
                continue
            
            try:
                # Check if package is installed
                result = subprocess.run(["brew", "list", "--formula"], 
                                      capture_output=True, text=True, check=True)
                if pkg in result.stdout.splitlines():
                    print(f"Reinstalling {pkg}...")
                    subprocess.run(["brew", "reinstall", pkg], check=True)
                else:
                    print(f"Package {pkg} not installed, installing...")
                    subprocess.run(["brew", "install", pkg], check=True)
            except subprocess.CalledProcessError as e:
                print(f"Error with {pkg}: {e}")
                return False
        
        return True

    def generate_brew_bundle(self, brews: List[Dict[str, Any]], casks: List[str]) -> str:
        """Generate brew bundle content."""
        bundle_lines = []
        
        # Add brews
        for brew in brews:
            if brew.get("type") == "string":
                bundle_lines.append(f'brew "{brew["name"]}"')
            else:
                # Map brew package
                line_parts = [f'brew "{brew["name"]}"']
                
                # Add arguments
                if "args" in brew:
                    args_list = [f'"{arg}"' for arg in brew["args"]]
                    line_parts.append(f'args: [{", ".join(args_list)}]')
                
                # Add alternative-only arguments
                if (self._is_alternative_homebrew() and 
                    "alternative_only" in brew and 
                    "args" in brew["alternative_only"]):
                    alt_args = [f'"{arg}"' for arg in brew["alternative_only"]["args"]]
                    line_parts.append(f'args: [{", ".join(alt_args)}]')
                
                bundle_lines.append(", ".join(line_parts))
        
        # Add casks
        for cask in casks:
            bundle_lines.append(f'cask "{cask}"')
        
        return "\n".join(bundle_lines)
    
    def install_with_bundle(self, bundle_content: str) -> bool:
        """Install packages using brew bundle."""
        if not bundle_content.strip():
            return True
        
        print("Installing remaining packages with brew bundle...")
        
        try:
            # Use brew bundle with stdin - show output in real time
            process = subprocess.Popen(
                ["brew", "bundle", "--file=-"],
                stdin=subprocess.PIPE,
                text=True
            )
            
            # Send bundle content and close stdin
            process.communicate(input=bundle_content)
            
            if process.returncode == 0:
                print("✅ Brew bundle installation completed successfully")
                return True
            else:
                print("❌ Brew bundle installation failed")
                return False
                
        except Exception as e:
            print(f"❌ Error running brew bundle: {e}")
            return False
    
    def setup_terminfo(self) -> bool:
        """Set up kitty TERMINFO for Emacs compatibility."""
        # Check if kitty is installed via Homebrew
        try:
            result = subprocess.run(["brew", "list", "--cask"], capture_output=True, text=True, check=True)
            if "kitty" not in result.stdout.splitlines():
                print("Skipping kitty TERMINFO setup (kitty not installed via Homebrew)")
                return True
        except subprocess.CalledProcessError:
            return True
        
        applications_path = self.config.get("applications_path", "/Applications")
        kitty_terminfo_path = Path(applications_path) / "kitty.app" / "Contents" / "Resources" / "kitty" / "terminfo"
        
        if not kitty_terminfo_path.exists():
            print(f"⚠️  Warning: kitty terminfo directory not found: {kitty_terminfo_path}")
            return True
        
        print("Setting up kitty TERMINFO database for Emacs compatibility...")
        
        home_dir = Path.home()
        terminfo_dirs = [home_dir / ".terminfo" / "x", home_dir / ".terminfo" / "78"]
        
        # Create terminfo directories (idempotent)
        for dir_path in terminfo_dirs:
            dir_path.mkdir(parents=True, exist_ok=True)
        
        # Copy kitty terminfo from bundle (always copy to get updates)
        source_file = kitty_terminfo_path / "78" / "xterm-kitty"
        if source_file.exists():
            dest_file = home_dir / ".terminfo" / "x" / "xterm-kitty"
            
            try:
                import shutil
                shutil.copy2(source_file, dest_file)
                print("Updated kitty terminfo at ~/.terminfo/x/xterm-kitty")
                
                # Create/update symlink for hex-based lookup
                symlink_path = home_dir / ".terminfo" / "78" / "xterm-kitty"
                if symlink_path.exists() or symlink_path.is_symlink():
                    symlink_path.unlink()
                
                symlink_path.symlink_to("../x/xterm-kitty")
                print("Updated symlink ~/.terminfo/78/xterm-kitty -> ~/.terminfo/x/xterm-kitty")
                
                print("✅ Kitty TERMINFO setup complete - Emacs should work properly in terminal mode")
                return True
                
            except Exception as e:
                print(f"❌ Error setting up kitty TERMINFO: {e}")
                return False
        else:
            print(f"⚠️  Warning: kitty terminfo file not found at expected location: {source_file}")
            return True
    
    def update_spotlight_index(self) -> bool:
        """Index ~/Applications for Spotlight."""
        if not self._is_alternative_homebrew():
            return True
        
        applications_dir = Path.home() / "Applications"
        if applications_dir.exists():
            print("Indexing ~/Applications for Spotlight...")
            try:
                subprocess.run(["mdimport", str(applications_dir)], check=False)
                return True
            except Exception as e:
                print(f"Warning: Failed to index Applications directory: {e}")
                return True
        
        return True
    
    def install_missing_packages_only(self) -> bool:
        """Install only missing packages (no upgrades)."""
        print("Checking for missing packages...")
        
        # Get currently installed packages
        try:
            result = subprocess.run(["brew", "list", "--formula"], 
                                  capture_output=True, text=True, check=True)
            installed_formulae = set(result.stdout.strip().split('\n'))
            
            result = subprocess.run(["brew", "list", "--cask"], 
                                  capture_output=True, text=True, check=True)
            installed_casks = set(result.stdout.strip().split('\n'))
        except subprocess.CalledProcessError as e:
            print(f"Error getting installed packages: {e}")
            return False
        
        # Classify packages
        individual_brews, bundle_brews, casks = self.classify_packages()
        
        # Filter to only missing packages
        missing_individual = []
        for pkg in individual_brews:
            pkg_name = pkg.get('name') if isinstance(pkg, dict) else pkg
            if pkg_name and pkg_name not in installed_formulae:
                missing_individual.append(pkg)
                print(f"  Missing formula: {pkg_name}")
        
        missing_bundle = []
        for pkg in bundle_brews:
            pkg_name = pkg.get('name') if isinstance(pkg, dict) else pkg
            if pkg_name and pkg_name not in installed_formulae:
                missing_bundle.append(pkg)
                print(f"  Missing formula: {pkg_name}")
        
        missing_casks = []
        for cask in casks:
            cask_name = cask if isinstance(cask, str) else cask.get('name')
            if cask_name and cask_name not in installed_casks:
                missing_casks.append(cask)
                print(f"  Missing cask: {cask_name}")
        
        if not missing_individual and not missing_bundle and not missing_casks:
            print("✅ No missing packages to install")
            return True
        
        # Install missing packages
        print(f"\nInstalling {len(missing_individual) + len(missing_bundle)} missing formulae and {len(missing_casks)} missing casks...")
        
        # Install packages with environment variables first
        if missing_individual and not self.install_individual_packages(missing_individual):
            return False
        
        # Install remaining packages with brew bundle
        if missing_bundle or missing_casks:
            bundle_content = self.generate_brew_bundle(missing_bundle, missing_casks)
            if bundle_content.strip() and not self.install_with_bundle(bundle_content):
                return False
        
        print("✅ Missing packages installed successfully")
        return True
    
    def full_installation(self, first_run: bool = False) -> bool:
        """Perform full Homebrew installation process."""
        if first_run:
            print("Starting initial Homebrew setup...")
        else:
            print("Checking Homebrew packages...")
        
        # Install Homebrew if needed
        if not self.install_homebrew():
            return False
        
        # Set environment variables for alternative Homebrew
        if self._is_alternative_homebrew():
            os.environ["HOMEBREW_NO_INSTALL_FROM_API"] = "1"
            print("Set HOMEBREW_NO_INSTALL_FROM_API=1 to use local formula modifications")
        
        # Verify formula patches
        if not self.verify_formula_patches():
            return False
        
        # Apply formula patches (placeholder - would need template integration)
        # This is where the patch-homebrew-formulas template would be called
        
        # Install taps
        if not self.install_taps():
            return False
        
        if first_run:
            # First run: Install all packages
            print("\nPerforming initial package installation...")
            
            # Classify and install packages
            individual_brews, bundle_brews, casks = self.classify_packages()

            # Sort by install_order (then by original position for stability)
            def _pkg_name(p):
                return p.get("name") if isinstance(p, dict) else p
            individual_brews = sorted(
                list(enumerate(individual_brews)),
                key=lambda t: (self._get_install_order(_pkg_name(t[1])), t[0])
            )
            individual_brews = [p for _, p in individual_brews]

            bundle_brews = sorted(
                list(enumerate(bundle_brews)),
                key=lambda t: (self._get_install_order(_pkg_name(t[1])), t[0])
            )
            bundle_brews = [p for _, p in bundle_brews]
            
            # Install packages with environment variables first
            if not self.install_individual_packages(individual_brews):
                return False
            
            # Install remaining packages with brew bundle
            bundle_content = self.generate_brew_bundle(bundle_brews, casks)
            if not self.install_with_bundle(bundle_content):
                return False
        else:
            # Subsequent runs: Check for outdated packages first, then install missing
            print("\nChecking for package updates...")
            
            # Check for and rebuild outdated source-built packages
            # This is non-critical - don't fail the entire installation if rebuilds fail
            print("\nChecking for outdated source-built packages...")
            try:
                outdated = self.detect_outdated_source_builds()
                if outdated:
                    print(f"Found {len(outdated)} packages that need rebuilding due to dependency updates")
                    if not self.rebuild_outdated_packages():
                        print("⚠️  Some packages failed to rebuild, but installation continues")
                        print("  Run 'brew-check-outdated' manually to retry")
            except Exception as e:
                print(f"⚠️  Warning: Could not check for outdated packages: {e}")
                print("  Run 'brew-check-outdated' manually to check")
            
            # Now install any missing packages
            if not self.install_missing_packages_only():
                return False
        
        # Set up kitty TERMINFO
        if not self.setup_terminfo():
            return False
        
        # Update Spotlight index
        if not self.update_spotlight_index():
            return False
        
        # Update homebrew state file for alternative installations
        if self._is_alternative_homebrew():
            try:
                subprocess.run(["bash", "-c", "update_homebrew_state"], check=False)
                print("Updated homebrew state file")
            except Exception as e:
                print(f"Warning: Failed to update homebrew state: {e}")
        
        # Check for and rebuild outdated source-built packages
        # This is non-critical - don't fail the entire installation if rebuilds fail
        print("\nChecking for outdated source-built packages...")
        try:
            outdated = self.detect_outdated_source_builds()
            if outdated:
                print(f"Found {len(outdated)} packages that need rebuilding due to dependency updates")
                if not self.rebuild_outdated_packages():
                    print("⚠️  Some packages failed to rebuild, but installation continues")
                    print("  Run 'brew-check-outdated' manually to retry")
        except Exception as e:
            print(f"⚠️  Warning: Could not check for outdated packages: {e}")
            print("  Run 'brew-check-outdated' manually to check")
        
        print("✅ Full Homebrew installation completed successfully!")
        return True


def main():
    parser = argparse.ArgumentParser(
        description="Comprehensive Homebrew manager for Chezmoi"
    )
    parser.add_argument(
        "command",
        choices=["full-install", "force-reinstall", "simple-reinstall", "check-outdated", "rebuild-outdated"],
        help="Command to execute"
    )
    parser.add_argument(
        "--config",
        help="Runtime configuration as JSON string"
    )
    parser.add_argument(
        "--packages-file",
        type=Path,
        help="Override path to packages.yml file"
    )
    parser.add_argument(
        "--first-run",
        action="store_true",
        help="Indicate this is the first run (install all packages)"
    )
    parser.add_argument(
        "packages",
        nargs="*",
        help="Packages for force-reinstall or simple-reinstall commands"
    )
    
    args = parser.parse_args()
    
    manager = HomebrewManager(args.packages_file)
    
    if args.config:
        manager.load_runtime_config(args.config)
    
    if args.command == "full-install":
        success = manager.full_installation(first_run=args.first_run)
        sys.exit(0 if success else 1)
    elif args.command == "force-reinstall":
        if not args.packages:
            print("Error: force-reinstall requires package names")
            sys.exit(1)
        success = manager.force_reinstall_packages(args.packages)
        sys.exit(0 if success else 1)
    elif args.command == "simple-reinstall":
        if not args.packages:
            print("Error: simple-reinstall requires package names")
            sys.exit(1)
        success = manager.simple_reinstall_packages(args.packages)
        sys.exit(0 if success else 1)
    elif args.command == "check-outdated":
        outdated = manager.detect_outdated_source_builds()
        if not outdated:
            print("✅ No source-built packages have outdated dependencies")
            sys.exit(0)
        else:
            print(f"⚠️  Found {len(outdated)} source-built packages with outdated dependencies:\n")
            for pkg in outdated:
                print(f"• {pkg['name']}")
                print(f"  {pkg['newer_deps_count']}/{pkg['total_deps']} dependencies are newer")
                if pkg['newer_deps'][:3]:
                    print(f"  Examples: {', '.join(pkg['newer_deps'][:3])}")
                print()
            print(f"Run 'chezmoi-homebrew-manager rebuild-outdated' to rebuild them")
            sys.exit(1)
    elif args.command == "rebuild-outdated":
        success = manager.rebuild_outdated_packages()
        sys.exit(0 if success else 1)
    else:
        print(f"Unknown command: {args.command}")
        sys.exit(1)


if __name__ == "__main__":
    main()
