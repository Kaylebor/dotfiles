#!/usr/bin/env bash
# Managed Configurations Status Command
# Shows status of all managed JSON configuration files
# Can be run directly or with inherited Chezmoi flags via CHEZMOI_ARGS

set -euo pipefail

# Default values
VERBOSE=false
QUIET=false
FORMAT="table"
COLOR="auto"
SPECIFIC_CONFIG=""
SHOW_BACKUPS=false

# Color output helpers
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly NC='\033[0m' # No Color

# Normalize flags from multiple sources
normalize_flags() {
    local all_args=""
    
    # Collect from all sources: CHEZMOI_ARGS + direct script arguments
    all_args="${CHEZMOI_ARGS:-} $*"
    
    # Clean up extra spaces and store
    NORMALIZED_ARGS=" $(echo "$all_args" | tr -s ' ') "
}

# Parse flags with priority handling (direct args > CHEZMOI_ARGS > defaults)
parse_flags() {
    # Verbose flag
    for arg in "--verbose" "-v"; do
        [[ "$NORMALIZED_ARGS" =~ " $arg " ]] && VERBOSE=true && break
    done
    
    # Quiet flag
    for arg in "--quiet" "-q"; do
        [[ "$NORMALIZED_ARGS" =~ " $arg " ]] && QUIET=true && break
    done
    
    # Format detection with value extraction
    if [[ "$NORMALIZED_ARGS" =~ " --format "([^ ]+) ]] || 
       [[ "$NORMALIZED_ARGS" =~ " -f "([^ ]+) ]]; then
        FORMAT="${BASH_REMATCH[1]}"
    fi
    
    # Color control
    [[ "$NORMALIZED_ARGS" =~ " --no-color " ]] && COLOR="never"
    [[ "$NORMALIZED_ARGS" =~ " --color " ]] && COLOR="always"
    
    # Script-specific options
    if [[ "$NORMALIZED_ARGS" =~ " --config "([^ ]+) ]]; then
        SPECIFIC_CONFIG="${BASH_REMATCH[1]}"
    fi
    
    [[ "$NORMALIZED_ARGS" =~ " --backups " ]] && SHOW_BACKUPS=true
    
    # Help flag
    if [[ "$NORMALIZED_ARGS" =~ " --help " ]] || 
       [[ "$NORMALIZED_ARGS" =~ " -h " ]]; then
        show_help
        exit 0
    fi
    
    # Conflict resolution: quiet takes precedence over verbose
    if [[ "$QUIET" == "true" && "$VERBOSE" == "true" ]]; then
        VERBOSE=false
    fi
    
    # Color detection
    if [[ "$COLOR" == "auto" ]]; then
        if [[ -t 1 ]] && [[ "${TERM:-}" != "dumb" ]]; then
            COLOR="always"
        else
            COLOR="never"
        fi
    fi
}

# Colored output functions
use_color() {
    [[ "$COLOR" == "always" ]]
}

log_info() {
    if [[ "$QUIET" != "true" ]]; then
        if use_color; then
            echo -e "${BLUE}[INFO]${NC} $1"
        else
            echo "[INFO] $1"
        fi
    fi
}

log_verbose() {
    if [[ "$VERBOSE" == "true" && "$QUIET" != "true" ]]; then
        if use_color; then
            echo -e "${CYAN}[VERBOSE]${NC} $1"
        else
            echo "[VERBOSE] $1"
        fi
    fi
}

log_error() {
    if use_color; then
        echo -e "${RED}[ERROR]${NC} $1" >&2
    else
        echo "[ERROR] $1" >&2
    fi
}

show_help() {
    cat << 'EOF'
Usage: managed-configs-status [OPTIONS]

Check status of all managed JSON configurations

OPTIONS:
    -h, --help              Show this help message
    -v, --verbose           Show detailed information
    -q, --quiet             Minimal output (errors only)
    -f, --format FORMAT     Output format (table|json|yaml|brief|csv)
    --config NAME           Show status for specific config only
    --backups               Show backup file details
    --color                 Force color output
    --no-color              Disable color output

OUTPUT FORMATS:
    table                   Human-readable colored table (default)
    json                    Machine-readable JSON output
    yaml                    YAML output  
    brief                   One-line-per-config summary
    csv                     CSV format for spreadsheets

STATUS INDICATORS:
    âœ… In Sync              Template and destination match
    ðŸ”„ Modified             Destination has device-specific changes (expected)
    âš ï¸ Template Updated      Template is newer than destination
    âŒ Missing              Destination file doesn't exist
    ðŸ”§ Invalid JSON         Destination file has JSON syntax errors

EXAMPLES:
    managed-configs-status                    # Show status table
    managed-configs-status --format json      # JSON output
    managed-configs-status --config zed       # Check specific config
    managed-configs-status --verbose          # Show differences

CHEZMOI INTEGRATION:
    When CHEZMOI_ARGS environment variable is set, inherits those flags.
    Direct script arguments take priority over inherited flags.
    
    Example: CHEZMOI_ARGS="--verbose" managed-configs-status --quiet
    Result: --quiet wins (direct args have priority)
EOF
}

# Check individual configuration status
check_config_status() {
    local config_name="$1"
    local template_path="$2" 
    local dest_path="$3"
    local description="$4"
    local merge_strategy="$5"
    local max_backups="$6"
    
    log_verbose "Checking $config_name status..."
    
    # Initialize status info
    local status="unknown"
    local template_modified="N/A"
    local dest_modified="N/A"
    local template_size=0
    local dest_size=0
    local backup_count=0
    local backup_info=""
    local error_info=""
    
    # Check template file
    if [[ -f "$template_path" ]]; then
        template_modified=$(date -r "$template_path" "+%b %d %H:%M" 2>/dev/null || echo "N/A")
        template_size=$(wc -c < "$template_path" 2>/dev/null || echo 0)
    else
        log_error "Template file not found: $template_path"
        status="template_error"
        error_info="Template missing"
    fi
    
    # Count backup files
    if [[ -f "$dest_path" ]]; then
        local dest_dir="$(dirname "$dest_path")"
        local dest_basename="$(basename "$dest_path")"
        backup_count=$(find "$dest_dir" -maxdepth 1 -name "${dest_basename}.backup.*" -type f 2>/dev/null | wc -l || echo 0)
        
        if [[ "$SHOW_BACKUPS" == "true" && "$backup_count" -gt 0 ]]; then
            local latest_backup=$(find "$dest_dir" -maxdepth 1 -name "${dest_basename}.backup.*" -type f 2>/dev/null | xargs ls -1t 2>/dev/null | head -1)
            if [[ -n "$latest_backup" ]]; then
                backup_info="(latest: $(basename "$latest_backup"))"
            fi
        fi
    fi
    
    # Check destination file
    if [[ ! -f "$dest_path" ]]; then
        status="missing"
    else
        dest_modified=$(date -r "$dest_path" "+%b %d %H:%M" 2>/dev/null || echo "N/A")
        dest_size=$(wc -c < "$dest_path" 2>/dev/null || echo 0)
        
        # Validate destination JSON
        if ! jq empty "$dest_path" 2>/dev/null; then
            status="invalid_json"
            error_info="JSON syntax error"
            log_verbose "$config_name has invalid JSON"
        else
            # Generate template and compare
            local temp_template="/tmp/status-${config_name}-template.json"
            local temp_dest="/tmp/status-${config_name}-dest.json"
            
            # Generate template content
            if chezmoi execute-template -f "$template_path" 2>/dev/null | sed '/^[[:space:]]*\/\//d' > "$temp_template"; then
                # Validate template JSON
                if jq empty "$temp_template" 2>/dev/null; then
                    # Clean destination JSON (remove comments)
                    sed '/^[[:space:]]*\/\//d' "$dest_path" > "$temp_dest"
                    
                    # Compare normalized JSON
                    local template_hash=$(jq -S . "$temp_template" 2>/dev/null | sha256sum | cut -d' ' -f1)
                    local dest_hash=$(jq -S . "$temp_dest" 2>/dev/null | sha256sum | cut -d' ' -f1)
                    
                    if [[ "$template_hash" == "$dest_hash" ]]; then
                        status="in_sync"
                    else
                        status="modified"
                        
                        # Check if template is newer
                        if [[ "$template_path" -nt "$dest_path" ]]; then
                            status="template_updated"
                        fi
                        
                        # Show differences in verbose mode
                        if [[ "$VERBOSE" == "true" ]]; then
                            log_verbose "Configuration $config_name has changes:"
                            if command -v difft >/dev/null 2>&1; then
                                difft "$temp_template" "$temp_dest" 2>/dev/null || diff -u "$temp_template" "$temp_dest" | head -20
                            else
                                diff -u "$temp_template" "$temp_dest" | head -20
                            fi
                        fi
                    fi
                else
                    status="template_error"
                    error_info="Template generates invalid JSON"
                    log_error "Template for $config_name generates invalid JSON"
                fi
            else
                status="template_error" 
                error_info="Failed to execute template"
                log_error "Failed to execute template for $config_name"
            fi
            
            # Cleanup temp files
            rm -f "$temp_template" "$temp_dest"
        fi
    fi
    
    # Create status object
    cat << EOF
{
    "name": "$config_name",
    "description": "$description",
    "status": "$status",
    "template_path": "$template_path",
    "destination_path": "$dest_path",
    "template_modified": "$template_modified",
    "destination_modified": "$dest_modified",
    "template_size": $template_size,
    "destination_size": $dest_size,
    "merge_strategy": "$merge_strategy",
    "backups": {
        "count": $backup_count,
        "max": $max_backups,
        "info": "$backup_info"
    },
    "error": "$error_info"
}
EOF
}

# Format status symbol with color
format_status() {
    local status="$1"
    
    case "$status" in
        "in_sync")
            if use_color; then
                echo -e "${GREEN}âœ… In Sync${NC}"
            else
                echo "âœ“ In Sync"
            fi
            ;;
        "modified")
            if use_color; then
                echo -e "${CYAN}ðŸ”„ Modified${NC}"
            else
                echo "~ Modified"
            fi
            ;;
        "template_updated")
            if use_color; then
                echo -e "${YELLOW}âš ï¸  Updated${NC}"
            else
                echo "! Updated"
            fi
            ;;
        "missing")
            if use_color; then
                echo -e "${RED}âŒ Missing${NC}"
            else
                echo "âœ— Missing"
            fi
            ;;
        "invalid_json"|"template_error")
            if use_color; then
                echo -e "${RED}ðŸ”§ Error${NC}"
            else
                echo "âœ— Error"
            fi
            ;;
        *)
            if use_color; then
                echo -e "${YELLOW}? Unknown${NC}"
            else
                echo "? Unknown"
            fi
            ;;
    esac
}

# Output in table format
output_table() {
    local configs_json="$1"
    
    if [[ "$QUIET" == "true" ]]; then
        # In quiet mode, only show errors
        echo "$configs_json" | jq -r '.[] | select(.status == "missing" or .status == "invalid_json" or .status == "template_error") | .name + ": " + .status'
        return
    fi
    
    # Header
    if use_color; then
        echo -e "${BOLD}Managed Configurations Status${NC}"
        echo -e "${BOLD}==============================${NC}"
        echo
    else
        echo "Managed Configurations Status"
        echo "=============================="
        echo
    fi
    
    # Table headers
    printf "%-20s %-25s %-11s %-13s %-8s %-8s\n" "Configuration" "Status" "Template" "Destination" "Backups" "Strategy"
    printf "%-20s %-25s %-11s %-13s %-8s %-8s\n" "--------------------" "-------------------------" "-----------" "-------------" "--------" "--------"
    
    # Table rows
    echo "$configs_json" | jq -r '.[] | "\(.name)|\(.status)|\(.template_modified)|\(.destination_modified)|\(.backups.count)/\(.backups.max)|\(.merge_strategy)"' | \
    while IFS='|' read -r name status template_mod dest_mod backup_info strategy; do
        local formatted_status=$(format_status "$status")
        printf "%-20s %-25s %-11s %-13s %-8s %-8s\n" "$name" "$formatted_status" "$template_mod" "$dest_mod" "$backup_info" "$strategy"
    done
    
    echo
    
    # Summary
    local total=$(echo "$configs_json" | jq '. | length')
    local in_sync=$(echo "$configs_json" | jq '[.[] | select(.status == "in_sync")] | length')
    local modified=$(echo "$configs_json" | jq '[.[] | select(.status == "modified")] | length')
    local missing=$(echo "$configs_json" | jq '[.[] | select(.status == "missing")] | length')
    local errors=$(echo "$configs_json" | jq '[.[] | select(.status == "invalid_json" or .status == "template_error")] | length')
    
    if use_color; then
        echo -e "${BOLD}Summary:${NC} $total configs | ${GREEN}$in_sync in sync${NC} | ${CYAN}$modified modified${NC} | ${RED}$missing missing${NC} | ${RED}$errors errors${NC}"
    else
        echo "Summary: $total configs | $in_sync in sync | $modified modified | $missing missing | $errors errors"
    fi
    
    if [[ ! "$SHOW_BACKUPS" == "true" ]]; then
        echo
        echo "Legend: âœ… In Sync | ðŸ”„ Modified (device-specific) | âš ï¸ Template Updated | âŒ Missing | ðŸ”§ Error"
        echo "Use --backups to show backup file details, --verbose for differences"
    fi
}

# Output in other formats
output_json() {
    local configs_json="$1"
    
    # Wrap in summary object
    local total=$(echo "$configs_json" | jq '. | length')
    local in_sync=$(echo "$configs_json" | jq '[.[] | select(.status == "in_sync")] | length')
    local modified=$(echo "$configs_json" | jq '[.[] | select(.status == "modified")] | length') 
    local missing=$(echo "$configs_json" | jq '[.[] | select(.status == "missing")] | length')
    local errors=$(echo "$configs_json" | jq '[.[] | select(.status == "invalid_json" or .status == "template_error")] | length')
    
    jq -n --argjson configs "$configs_json" \
          --argjson total "$total" \
          --argjson in_sync "$in_sync" \
          --argjson modified "$modified" \
          --argjson missing "$missing" \
          --argjson errors "$errors" \
    '{
        configurations: $configs,
        summary: {
            total: $total,
            in_sync: $in_sync,
            modified: $modified,
            missing: $missing,
            errors: $errors
        }
    }'
}

output_yaml() {
    local configs_json="$1"
    
    # Convert JSON to YAML using yq if available, otherwise use basic conversion
    if command -v yq >/dev/null 2>&1; then
        output_json "$configs_json" | yq eval '.' -
    else
        log_error "yq not available for YAML output. Install yq or use --format json"
        exit 1
    fi
}

output_brief() {
    local configs_json="$1"
    
    echo "$configs_json" | jq -r '.[] | "\(.name): \(.status)"'
}

output_csv() {
    local configs_json="$1"
    
    echo "name,status,template_modified,destination_modified,backup_count,max_backups,merge_strategy,error"
    echo "$configs_json" | jq -r '.[] | [.name, .status, .template_modified, .destination_modified, .backups.count, .backups.max, .merge_strategy, .error] | @csv'
}

# Main execution
main() {
    # Initialize flags
    normalize_flags "$@"
    parse_flags
    
    log_verbose "Starting managed configurations status check..."
    log_verbose "Output format: $FORMAT, Color: $COLOR, Verbose: $VERBOSE, Quiet: $QUIET"
    
    # Get current OS for path resolution
    local current_os="{{ .chezmoi.os }}"
    log_verbose "Detected OS: $current_os"
    
    # Get chezmoi directories
    local source_dir="{{ .chezmoi.sourceDir }}"
    local home_dir="{{ .chezmoi.homeDir }}"
    
    log_verbose "Source directory: $source_dir"
    log_verbose "Home directory: $home_dir"
    
    # Check if managed configs metadata exists
    local metadata_file="$source_dir/.chezmoidata/managed-configs.yaml"
    if [[ ! -f "$metadata_file" ]]; then
        log_error "Managed configs metadata not found: $metadata_file"
        exit 1
    fi
    
    # Load and parse managed configurations metadata using yq
    {{- $configs := .managed_configs }}
    {{- if not $configs }}
    log_error "No managed configurations found in .chezmoidata/managed-configs.yaml"
    exit 1
    {{- end }}
    
    # Collect status for all configurations
    local all_status="["
    local first_config=true
    
    {{- range $configName, $config := $configs }}
    {{- $templatePath := printf "%s/%s" $.chezmoi.sourceDir $config.template }}
    {{- $destPath := "" }}
    {{- if kindIs "string" $config.destination }}
      {{- $destPath = printf "%s/%s" $.chezmoi.homeDir $config.destination }}
    {{- else if kindIs "map" $config.destination }}
      {{- if hasKey $config.destination $.chezmoi.os }}
        {{- $destPath = printf "%s/%s" $.chezmoi.homeDir (index $config.destination $.chezmoi.os) }}
      {{- end }}
    {{- end }}
    
    {{- if $destPath }}
    # Check {{ $configName }}
    {{- $configMaxBackups := 0 }}
    {{- if hasKey $config "max_backups" }}
      {{- $configMaxBackups = $config.max_backups }}
    {{- end }}
    {{- $globalMaxBackups := 5 }}
    {{- if hasKey $.global "max_backups" }}  
      {{- $globalMaxBackups = $.global.max_backups }}
    {{- end }}
    {{- $maxBackups := $configMaxBackups }}
    {{- if eq $maxBackups 0 }}
      {{- $maxBackups = $globalMaxBackups }}
    {{- end }}
    
    if [[ -z "$SPECIFIC_CONFIG" || "$SPECIFIC_CONFIG" == "{{ $configName }}" ]]; then
        if [[ "$first_config" != "true" ]]; then
            all_status="$all_status,"
        fi
        
        local config_status=$(check_config_status \
            "{{ $configName }}" \
            "{{ $templatePath }}" \
            "{{ $destPath }}" \
            "{{ $config.description | default "Managed configuration" }}" \
            "{{ $config.merge_strategy | default "shallow" }}" \
            "{{ $maxBackups }}")
        
        all_status="$all_status$config_status"
        first_config=false
    fi
    {{- else }}
    log_verbose "Skipping {{ $configName }} - no destination path defined for OS: $current_os"
    {{- end }}
    {{- end }}
    
    all_status="$all_status]"
    
    # Validate JSON
    if ! echo "$all_status" | jq empty 2>/dev/null; then
        log_error "Failed to generate valid status JSON"
        log_verbose "Generated JSON: $all_status"
        exit 1
    fi
    
    # Output in requested format
    case "$FORMAT" in
        "table")
            output_table "$all_status"
            ;;
        "json")
            output_json "$all_status"
            ;;
        "yaml")
            output_yaml "$all_status"
            ;;
        "brief")
            output_brief "$all_status"
            ;;
        "csv")
            output_csv "$all_status"
            ;;
        *)
            log_error "Unknown format: $FORMAT"
            log_error "Supported formats: table, json, yaml, brief, csv"
            exit 1
            ;;
    esac
    
    # Exit code based on status
    local exit_code=0
    local missing_count=$(echo "$all_status" | jq '[.[] | select(.status == "missing")] | length')
    local error_count=$(echo "$all_status" | jq '[.[] | select(.status == "invalid_json" or .status == "template_error")] | length')
    
    if [[ "$error_count" -gt 0 ]]; then
        exit_code=2  # Errors
    elif [[ "$missing_count" -gt 0 ]]; then
        exit_code=1  # Missing files
    fi
    
    log_verbose "Status check completed with exit code: $exit_code"
    exit $exit_code
}

# Run main function
main "$@"