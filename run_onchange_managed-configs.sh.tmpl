#!/usr/bin/env bash
# Generic JSON configuration merge script
# Merges Chezmoi-managed base settings with existing device-specific settings
# Configuration driven by .chezmoidata/managed-configs.yaml

# Hash-based change detection for all managed templates and metadata
# hash: {{ include ".chezmoidata/managed-configs.yaml" | sha256sum }}
{{- range $configName, $config := .managed_configs }}
# hash: {{ include $config.template | sha256sum }}
{{- end }}
# Environment-based hashes for dynamic content
# hash: {{ env "CHEZMOI_GITHUB_PAT" | sha256sum }}
# hash: {{ .skip1Password | toString | sha256sum }}
# hash: {{ env "CHEZMOI_SKIP_1PASSWORD" | sha256sum }}

set -euo pipefail

# Parse Chezmoi command line flags
DRY_RUN=false
VERBOSE=false
if [[ " ${CHEZMOI_ARGS:-} " =~ " --dry-run " ]] || [[ " ${CHEZMOI_ARGS:-} " =~ " -n " ]]; then
    DRY_RUN=true
fi
if [[ " ${CHEZMOI_ARGS:-} " =~ " --verbose " ]] || [[ " ${CHEZMOI_ARGS:-} " =~ " -v " ]]; then
    VERBOSE=true
fi

# Color output helpers
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

log_info() {
    if [[ "$VERBOSE" == "true" ]]; then
        echo -e "${BLUE}[INFO]${NC} $1"
    fi
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Always visible info (not controlled by verbose)
log_always() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# Function to manage backup rotation (keep only N most recent backups)
manage_backup_rotation() {
    local config_file="$1"
    local max_backups="${2:-5}"  # Default to 5 backups
    
    local backup_dir="$(dirname "$config_file")"
    local backup_basename="$(basename "$config_file")"
    
    log_info "Managing backup rotation for $config_file (max: $max_backups)"
    
    # Find all backup files for this config (sorted by modification time, newest first)
    local backup_files=()
    while IFS= read -r -d '' backup_file; do
        backup_files+=("$backup_file")
    done < <(find "$backup_dir" -maxdepth 1 -name "${backup_basename}.backup.*" -type f -print0 2>/dev/null | xargs -0 ls -1t 2>/dev/null)
    
    # Remove excess backups
    if [[ ${#backup_files[@]} -gt $max_backups ]]; then
        local files_to_remove=${#backup_files[@]}
        files_to_remove=$((files_to_remove - max_backups))
        
        log_info "Found ${#backup_files[@]} backups, removing $files_to_remove oldest files"
        
        for ((i = max_backups; i < ${#backup_files[@]}; i++)); do
            local old_backup="${backup_files[i]}"
            if [[ "$DRY_RUN" == "true" ]]; then
                log_info "Would remove old backup: $(basename "$old_backup") (DRY RUN)"
            else
                log_info "Removing old backup: $(basename "$old_backup")"
                rm -f "$old_backup"
            fi
        done
    else
        log_info "Found ${#backup_files[@]} backups (within limit of $max_backups)"
    fi
}

# Function to create backup with rotation
create_backup_with_rotation() {
    local source_file="$1"
    local max_backups="${2:-5}"
    
    if [[ -f "$source_file" ]]; then
        local backup_file="${source_file}.backup.$(date +%s)"
        
        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "Would create backup: $(basename "$backup_file") (DRY RUN)"
        else
            log_info "Creating backup: $(basename "$backup_file")"
            cp "$source_file" "$backup_file"
        fi
        
        # Manage rotation after creating backup
        manage_backup_rotation "$source_file" "$max_backups"
    fi
}

# Function to create jq filter for merging configurations
create_merge_filter() {
    local merge_strategy="$1"
    
    case "$merge_strategy" in
        "deep")
            # Deep merge: recursively merge objects, arrays get replaced
            # Template provides base, existing values override at all levels
            echo 'def deep_merge(template; existing):
                if (template | type) == "object" and (existing | type) == "object" then
                    template * existing + 
                    (template | to_entries | map(
                        select(.value | type == "object") | 
                        {key: .key, value: deep_merge(.value; existing[.key] // {})}
                    ) | from_entries)
                else
                    existing // template
                end;
            deep_merge(.[0]; .[1])'
            ;;
        "shallow"|*)
            # Simple merge: template gets overridden by existing file values
            # This preserves all existing device-specific settings automatically
            echo '.[0] * .[1]'
            ;;
    esac
}

# Function to merge configuration file
merge_config_file() {
    local config_name="$1"
    local template_path="$2"
    local dest_path="$3"
    local preserve_fields_str="$4"
    local merge_strategy="$5"
    local description="$6"
    local max_backups="$7"
    
    log_info "Processing $config_name ($description)..."
    
    # Note: preserve_fields_str is kept for compatibility but not used in simple merge
    # The simple merge (template * existing) preserves all existing fields naturally
    
    # Ensure destination directory exists
    local dest_dir="$(dirname "$dest_path")"
    mkdir -p "$dest_dir"
    
    # Generate base file from Chezmoi template and remove JSON comments
    local temp_base="/tmp/managed-config-${config_name}-base.json"
    log_info "Generating base configuration from template..."
    if ! chezmoi execute-template -f "$template_path" | sed '/^[[:space:]]*\/\//d' > "$temp_base"; then
        log_error "Failed to generate template for $config_name"
        return 1
    fi
    
    # Validate generated JSON
    if ! jq empty "$temp_base" 2>/dev/null; then
        log_error "Generated template for $config_name is not valid JSON"
        cat "$temp_base"
        return 1
    fi
    
    # Check if existing file exists
    if [[ -f "$dest_path" ]]; then
        log_info "Found existing configuration, merging with preserved fields..."
        
        local temp_existing="/tmp/managed-config-${config_name}-existing.json"
        local temp_merged="/tmp/managed-config-${config_name}-merged.json"
        
        # Remove comments from existing file and validate
        sed '/^[[:space:]]*\/\//d' "$dest_path" > "$temp_existing"
        if ! jq empty "$temp_existing" 2>/dev/null; then
            if [[ "$DRY_RUN" == "true" ]]; then
                log_warning "Existing $config_name file has invalid JSON - would backup and use template only (DRY RUN)"
                log_success "$config_name would be updated with backup (DRY RUN)"
            else
                log_warning "Existing $config_name file has invalid JSON, backing up and using template only"
                # Use the new backup function with rotation
                create_backup_with_rotation "$dest_path" "$max_backups"
                cp "$temp_base" "$dest_path"
                log_success "$config_name updated (existing file backed up)"
            fi
            rm -f "$temp_base" "$temp_existing"
            return 0
        fi
        
        # Create merge filter based on strategy
        local merge_filter=$(create_merge_filter "$merge_strategy")
        
        # Perform merge
        if ! jq -s "$merge_filter" "$temp_base" "$temp_existing" > "$temp_merged"; then
            log_error "Failed to merge $config_name configurations"
            rm -f "$temp_base" "$temp_existing" "$temp_merged"
            return 1
        fi
        
        # Validate merged JSON
        if ! jq empty "$temp_merged" 2>/dev/null; then
            log_error "Merged configuration for $config_name is not valid JSON"
            rm -f "$temp_base" "$temp_existing" "$temp_merged"
            return 1
        fi
        
        # Check for differences (compare formatted JSON to avoid whitespace issues)
        local current_formatted="/tmp/managed-config-${config_name}-current.json"
        local merged_formatted="/tmp/managed-config-${config_name}-merged-formatted.json"
        
        jq --sort-keys . "$dest_path" > "$current_formatted" 2>/dev/null || cp "$dest_path" "$current_formatted"
        jq --sort-keys . "$temp_merged" > "$merged_formatted"
        
        if ! diff -q "$current_formatted" "$merged_formatted" > /dev/null 2>&1; then
            echo
            echo "======================================"
            log_info "Changes detected in $config_name:"
            echo "======================================"
            {{- if lookPath "difft" }}
            difft "$current_formatted" "$merged_formatted" 2>/dev/null || diff -u "$current_formatted" "$merged_formatted"
            {{- else }}
            diff -u "$current_formatted" "$merged_formatted"
            {{- end }}
            echo "======================================"
            echo
            
            if [[ "$DRY_RUN" == "true" ]]; then
                log_success "$config_name - changes would be applied (DRY RUN)"
            else
                read -p "Apply these changes? (y/N): " -n 1 -r
                echo
                if [[ $REPLY =~ ^[Yy]$ ]]; then
                    cp "$temp_merged" "$dest_path"
                    log_success "$config_name updated successfully"
                else
                    log_info "$config_name changes cancelled"
                fi
            fi
        else
            log_success "$config_name - no changes detected"
        fi
        
        # Cleanup
        rm -f "$temp_base" "$temp_existing" "$temp_merged" "$current_formatted" "$merged_formatted"
        
    else
        if [[ "$DRY_RUN" == "true" ]]; then
            log_info "No existing configuration found - would create new file (DRY RUN)"
            log_success "$config_name would be created successfully (DRY RUN)"
        else
            log_info "No existing configuration found, creating new file..."
            cp "$temp_base" "$dest_path"
            log_success "$config_name created successfully"
        fi
        rm -f "$temp_base"
    fi
}

# Main execution
if [[ "$DRY_RUN" == "true" ]]; then
    log_always "Starting managed configuration merge process (DRY RUN MODE)"
    log_always "No changes will be made to configuration files"
else
    log_always "Starting managed configuration merge process..."
fi

{{- $configs := .managed_configs }}
{{- if not $configs }}
log_warning "No managed configurations found in .chezmoidata/managed-configs.yaml"
exit 0
{{- end }}

# Determine current OS
readonly CURRENT_OS="{{ .chezmoi.os }}"
log_info "Detected OS: $CURRENT_OS"

# Process each managed configuration
{{- range $configName, $config := $configs }}
{{- $templatePath := printf "%s/%s" $.chezmoi.sourceDir $config.template }}
{{- $destPath := "" }}
{{- if kindIs "string" $config.destination }}
  {{- $destPath = printf "%s/%s" $.chezmoi.homeDir $config.destination }}
{{- else if kindIs "map" $config.destination }}
  {{- if hasKey $config.destination $.chezmoi.os }}
    {{- $destPath = printf "%s/%s" $.chezmoi.homeDir (index $config.destination $.chezmoi.os) }}
  {{- else }}
    {{- $destPath = "" }}
  {{- end }}
{{- end }}

{{- if $destPath }}
# Process {{ $configName }}
{{- $preserveFieldsStr := join " " ($config.preserve_fields | default list) }}
{{- $configMaxBackups := 0 }}
{{- if hasKey $config "max_backups" }}
  {{- $configMaxBackups = $config.max_backups }}
{{- end }}
{{- $globalMaxBackups := 5 }}
{{- if hasKey $.global "max_backups" }}  
  {{- $globalMaxBackups = $.global.max_backups }}
{{- end }}
{{- $maxBackups := $configMaxBackups }}
{{- if eq $maxBackups 0 }}
  {{- $maxBackups = $globalMaxBackups }}
{{- end }}
merge_config_file \
    "{{ $configName }}" \
    "{{ $templatePath }}" \
    "{{ $destPath }}" \
    "{{ $preserveFieldsStr }}" \
    "{{ $config.merge_strategy | default "shallow" }}" \
    "{{ $config.description | default "Managed configuration" }}" \
    "{{ $maxBackups }}"

{{- else }}
log_warning "Skipping {{ $configName }} - no destination path defined for OS: $CURRENT_OS"
{{- end }}
{{- end }}

log_success "Managed configuration merge process completed"